$ ruby --version
ruby 2.2.4p230 (2015-12-16 revision 53155) [i386-mingw32]

$ gem --version
2.6.7

$ rake --version
rake, version 11.3.0

$ rails --version
Rails 4.2.5.1

$ bundler --version
Bundler version 1.13.1

$ rails new sample_app

$ cd sample_app

[
$ bundle install --without production

# In case of previously installed a version of a gem (such as Rails itself) other than the one specified by the Gemfile,  update the gems with bundle update to make sure the versions match
$ bundle update 
]

# Ruby on Rails Tutorial: sample application This is the sample application for the [*Ruby on Rails Tutorial: Learn Web Development with Rails*](http://www.railstutorial.org/) by [Michael Hartl](http://www.michaelhartl.com/).


## 3.2 Static pages

# Generate the Static Pages # updates the routes file (config/routes.rb)
$ rails generate controller StaticPages home help

[
# Full command = Shortcut
$ rails server = $ rails s
$ rails console = $ rails c
$ rails generate = $ rails g
$ bundle install = $ bundle
$ rake test = $ rake

# Undo code generation 
# rails destroy controller
$ rails generate controller StaticPages home help
$ rails destroy controller StaticPages home help

# rails destroy model
$ rails generate model User name:string email:string
$ rails destroy model User

# Undoing migrations
$ bundle exec rake db:migrate
$ bundle exec rake db:rollback
# rollback to the beginning
$ bundle exec rake db:migrate VERSION=0
]

# Rule 
# get 'static_pages/home' maps requests for the URL /static_pages/home to the home action in the Static Pages controller
# 'get' is for the route to respond to a GET request, which is one of the fundamental HTTP verbs supported by the hypertext transfer protocol
# i.e., generate a home action inside the Static Pages controller we automatically get a page at the address /static_pages/home

# Rails development server
[ $ rails server -b $IP -p $PORT # Use only `rails server` if running locally ]
# Note: cd to app folder again in case of directory change/rename
$ bin/rails server

http://localhost:3000/static_pages/home

# Custom static pages
Custom HTML for the Home page.app/views/static_pages/home.html.erb
<h1>Sample App</h1> 
<p> This is the home page for the 
  <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> 
  sample application. 
</p>

# Custom HTML for the Help page.app/views/static_pages/help.html.erb
<h1>Help</h1> 
  <p> Get help on the Ruby on Rails Tutorial at the 
  <a href="http://www.railstutorial.org/#help">Rails Tutorial help section</a>. 
  To get help on this sample app, see the 
  <a href="http://www.railstutorial.org/book"><em>Ruby on Rails Tutorial</em> book</a>. 
</p>

http://localhost:3000/static_pages/home

http://localhost:3000/static_pages/help


## 3.3 Getting started with testing
# test/controllers/static_pages_controller_test.rb
$ bundle exec rake test
2 runs, 2 assertions, 0 failures, 0 errors, 0 skips

# Red, Green, Refactor
# You won't actually see the color green unless you add MiniTest reporters in the optional advanced testing setup
# The tests take some time to start, which is due to two factors: 
(1) starting the Spring server to preload parts of the Rails environment, which only happens the first time
(2) overhead associated with Ruby startup time. (The second factor is ameliorated when using Guard)

# first step in this cycle, getting to RED by writing a failing test
# A test for the About page
# test/controllers/static_pages_controller_test.rb
require 'test_helper'

class StaticPagesControllerTest < ActionController::TestCase
  test "should get home" do
    get :home
    assert_response :success
  end

  test "should get help" do
    get :help
    assert_response :success
  end

  test "should get about" do
    get :about
    assert_response :success
  end
  
end

# RED
$ bundle exec rake test
ActionController::UrlGenerationError: No route matches {:action=>"about", :controller=>"static_pages"}
3 runs, 2 assertions, 0 failures, 1 errors, 0 skips

# Adding the about route
# config/routes.rb
Rails.application.routes.draw do
  get 'static_pages/home'

  get 'static_pages/help'

  get 'static_pages/about'
end

# RED
$ bundle exec rake test
AbstractController::ActionNotFound: The action 'about' could not be found for StaticPagesController
3 runs, 2 assertions, 0 failures, 1 errors, 0 skips

# The Static Pages controller with added about action
# app/controllers/static_pages_controller.rb
class StaticPagesController < ApplicationController
  def home
  end

  def help
  end
  
  def about
  end
end

# RED
$ bundle exec rake test
ActionView::MissingTemplate: Missing template static_pages/about
3 runs, 2 assertions, 0 failures, 1 errors, 0 skips

# Create file app/views/static_pages/about.html.erb
$ touch app/views/static_pages/about.html.erb

# app/views/static_pages/about.html.erb
<h1>About</h1> 
<p> 
  The <a href="http://www.railstutorial.org/"><em>Ruby on Rails 
  Tutorial</em></a> is a 
  <a href="http://www.railstutorial.org/book">book</a> and 
  <a href="http://screencasts.railstutorial.org/">screencast series</a> 
  to teach web development with 
  <a href="http://rubyonrails.org/">Ruby on Rails</a>. 
  This is the sample application for the tutorial. 
</p>

# GREEN
$ bundle exec rake test
3 tests, 3 assertions, 0 failures, 0 errors, 0 skips

http://localhost:3000/static_pages/about

# Refactor
# Refer to Layouts and embedded Ruby (Refactor) below

# Dynamic pages

# temporary change 
# disabling application.html.erb 
# Not normally done in a real application
$ mv app/views/layouts/application.html.erb layout_file 


# The Static Pages controller test with title tests
# test/controllers/static_pages_controller_test.rb
require 'test_helper'

class StaticPagesControllerTest < ActionController::TestCase
  test "should get home" do
    get :home
    assert_response :success
    assert_select "title", "Home | Ruby on Rails Tutorial Sample App"
  end

  test "should get help" do
    get :help
    assert_response :success
    assert_select "title", "Help | Ruby on Rails Tutorial Sample App"
  end

  test "should get about" do
    get :about
    assert_response :success
    assert_select "title", "About | Ruby on Rails Tutorial Sample App"
  end
  
end

# RED
$ bundle exec rake test
3 runs, 6 assertions, 3 failures, 0 errors, 0 skips

# The view for the Home page with full HTML structure
# app/views/static_pages/home.html.erb
<!DOCTYPE html> 
<html> 
  <head>
    <title>Home | Ruby on Rails Tutorial Sample App</title> 
  </head> 
  <body> 
    <h1>Sample App</h1> 
    <p> 
      This is the home page for the 
      <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> sample application. 
    </p>   
  </body> 
</html>

http://localhost:3000/static_pages/home


# The view for the Help page with full HTML structure
# app/views/static_pages/help.html.erb
<!DOCTYPE html> 
<html> 
  <head>
    <title>Help | Ruby on Rails Tutorial Sample App</title> 
  </head> 
  <body> 
    <h1>Help</h1> 
    <p> Get help on the Ruby on Rails Tutorial at the <a href="http://www.railstutorial.org/#help">Rails Tutorial help section</a>. To get help on this sample app, see the <a href="http://www.railstutorial.org/book"><em>Ruby on Rails Tutorial</em> book</a>. 
    </p> 
  </body> 
</html>

# The view for the About page with full HTML structure
# app/views/static_pages/about.html.erb
<!DOCTYPE html> 
<html> 
  <head> 
    <title>About | Ruby on Rails Tutorial Sample App</title> 
  </head> 
  <body> 
    <h1>About</h1> 
    <p> 
      The <a href="http://www.railstutorial.org/"><em>Ruby on Rails Tutorial</em></a> is a 
      <a href="http://www.railstutorial.org/book">book</a> and 
      <a href="http://screencasts.railstutorial.org/">screencast series</a> to teach web development with 
      <a href="http://rubyonrails.org/">Ruby on Rails</a>. 
      This is the sample application for the tutorial. 
    </p> 
  </body> 
</html>

# GREEN
$ bundle exec rake test
3 runs, 6 assertions, 0 failures, 0 errors, 0 skips

# Layouts and embedded Ruby (Refactor)
# "Don't Repeat Yourself" (DRY) principle; in this section we'll "DRY out our code"
# The view for the Home page with an embedded Ruby title
# app/views/static_pages/home.html.erb
<% provide(:title, "Home") %> 
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= yield(:title) %> | Ruby on Rails Tutorial Sample App</title> 
  </head>
  <body> <h1>Sample App</h1> 
    <p> 
      This is the home page for the 
      <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> 
      sample application. 
    </p> 
  </body> 
</html>

# GREEN 
$ bundle exec rake test
3 runs, 6 assertions, 0 failures, 0 errors, 0 skips

# The view for the Help page with an embedded Ruby title
# app/views/static_pages/help.html.erb
<% provide(:title, "Help") %> 
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= yield(:title) %> | Ruby on Rails Tutorial Sample App</title> 
  </head> 
  <body> 
    <h1>Help</h1> 
    <p> 
      Get help on the Ruby on Rails Tutorial at the <a href="http://www.railstutorial.org/#help">Rails Tutorial help section</a>. 
     To get help on this sample app, see the
     <a href="http://www.railstutorial.org/book"><em>Ruby on Rails Tutorial</em> book</a>. 
    </p> 
  </body> 
</html>

# The view for the About page with an embedded Ruby title
# app/views/static_pages/about.html.erb
<% provide(:title, "About") %> 
<!DOCTYPE html> 
  <html> 
  <head> 
    <title><%= yield(:title) %> | Ruby on Rails Tutorial Sample App</title> 
  </head> 
  <body> 
    <h1>About</h1> 
    <p> 
      The <a href="http://www.railstutorial.org/"><em>Ruby on Rails Tutorial</em></a> is a 
      <a href="http://www.railstutorial.org/book">book</a> and 
      <a href="http://screencasts.railstutorial.org/">screencast series</a> to teach web development with 
      <a href="http://rubyonrails.org/">Ruby on Rails</a>.        
      This is the sample application for the tutorial. 
    </p> 
  </body> 
</html>

# restore application.html.erb
# Rails comes with a special layout file calledapplication.html.erb
$ mv layout_file app/views/layouts/application.html.erb

# The sample application site layout
# app/views/layouts/application.html.erb
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= yield(:title) %> | Ruby on Rails Tutorial Sample App</title> 
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true %> 
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %> 
    <%= csrf_meta_tags %> 
  </head> 
  <body> 
    <%= yield %> 
  </body> 
</html>


# The Home page with HTML structure removed
# app/views/static_pages/home.html.erb 
<% provide(:title, "Home") %> 
<h1>Sample App</h1> 
<p> 
  This is the home page for the 
  <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> sample application. 
</p>

# The Help page with HTML structure removed
# app/views/static_pages/help.html.erb 
<% provide(:title, "Help") %> 
<h1>Help</h1> 
<p> 
  Get help on the Ruby on Rails Tutorial at the 
  <a href="http://www.railstutorial.org/#help">Rails Tutorial help section</a>. 
  To get help on this sample app, see the 
  <a href="http://www.railstutorial.org/book"><em>Ruby on Rails Tutorial</em> book</a>. 
</p>

# The About page with HTML structure removed
# app/views/static_pages/about.html.erb 
<% provide(:title, "About") %> 
<h1>About</h1> 
<p> 
  The <a href="http://www.railstutorial.org/"><em>Ruby on Rails Tutorial</em></a> is a 
  <a href="http://www.railstutorial.org/book">book</a> and 
  <a href="http://screencasts.railstutorial.org/">screencast series</a> to teach web development with 
  <a href="http://rubyonrails.org/">Ruby on Rails</a>.   
  This is the sample application for the tutorial. 
</p>

# GREEN 
$ bundle exec rake test
3 runs, 6 assertions, 0 failures, 0 errors, 0 skips

# Setting the root route to the Home page
# config/routes.rb
Rails.application.routes.draw do
  root 'static_pages#home'

  get 'static_pages/help'

  get 'static_pages/about'
end

http://localhost:3000/

# Unix processes
On Unix-like systems such as Linux and OS X, user and system tasks each take place within a well-defined container called a process. To see all the processes on your system, you can use the ps command with the aux options:

$ ps aux

To filter the processes by type, you can run the results of ps through the grep pattern-matcher using a Unix pipe |:

[
$ ps aux | grep spring 
 ubuntu 12241 0.3 0.5 589960 178416 ? Ssl Sep20 1:46 spring app | sample_app | started 7 hours ago

The result shown gives some details about the process, but the most important thing is the first number, which is the process id, or pid. To eliminate an unwanted process, use thekill command to issue the Unix kill code (which happens to be 9) to the pid: 

$ kill -9 12241

This is the technique I recommend for killing individual processes, such as a rogue Rails server (with the pid found via ps aux | grep server), but sometimes it's convenient to kill all the processes matching a particular process name, such as when you want to kill all the spring processes gunking up your system. In this particular case, you should first try stopping the processes with the spring command itself:

$ spring stop

Sometimes this doesn't work, though, and you can kill all the processes with name springusing the pkill command as follows:

$ pkill -9 -f spring

Any time something isn't behaving as expected or a process appears to be frozen, it's a good idea to run ps aux to see what's going on, and then run kill -9 <pid> or pkill -9 -f <name> to clear things up.
]


## 4 Rails-flavored Ruby

# Defining a full_title helper
# app/helpers/application_helper.rb
module ApplicationHelper
  
  # Returns the full title on a per-page basis. 
  def full_title(page_title = '') 
    base_title = "Ruby on Rails Tutorial Sample App" 
    if page_title.empty? 
      base_title 
    else 
      page_title + " | " + base_title 
    end 
  end 
end


# The site layout with the full_title helper
# The full_title helper returns a base title, "Ruby on Rails Tutorial Sample App" if no page title is defined
# And adds a vertical bar preceded by the page title if one is defined
# app/views/layouts/application.html.erb
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= full_title(yield(:title)) %></title> 
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true %> 
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %> 
    <%= csrf_meta_tags %> 
  </head> 
  <body> 
    <%= yield %> 
  </body> 
</html>

# An updated test for the Home page's title
# test/controllers/static_pages_controller_test.rb
require 'test_helper'

class StaticPagesControllerTest < ActionController::TestCase
  test "should get home" do
    get :home
    assert_response :success
    assert_select "title", "Ruby on Rails Tutorial Sample App"
  end

  test "should get help" do
    get :help
    assert_response :success
    assert_select "title", "Help | Ruby on Rails Tutorial Sample App"
  end

  test "should get about" do
    get :about
    assert_response :success
    assert_select "title", "About | Ruby on Rails Tutorial Sample App"
  end
  
end

# RED
$ bundle exec rake test
3 runs, 6 assertions, 1 failures, 0 errors, 0 skips

# The Home page with no custom page title
# app/views/static_pages/home.html.erb
<h1>Sample App</h1> 
<p> 
  This is the home page for the 
  <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> 
  sample application. 
</p>

# GREEN
$ bundle exec rake test
3 runs, 6 assertions, 0 failures, 0 errors, 0 skips


# An annotated title_helper
# app/helpers/application_helper.rb
module ApplicationHelper 
  # Returns the full title on a per-page basis. # Documentation comment
  def full_title(page_title = '') # Method def, optional arg
    base_title = "Ruby on Rails Tutorial Sample App" # Variable assignment
    if page_title.empty? # Boolean test
      base_title # Implicit return
    else
      page_title + " | " + base_title # String concatenation
    end
  end
end


## 5 Filling in the layout

# The site layout with added structure
# app/views/layouts/application.html.erb
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= full_title(yield(:title)) %></title> 
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true %> 
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %> 
    <%= csrf_meta_tags %> 
    <!--[if lt IE 9]> 
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js"> </script> 
    <![endif]--> 
  </head> 
  <body> 
    <header class="navbar navbar-fixed-top navbar-inverse"> 
      <div class="container"> 
        <%= link_to "sample app", '#', id: "logo" %> 
        <nav> 
          <ul class="nav navbar-nav navbar-right"> 
            <li>
              <%= link_to "Home", '#' %>
            </li> 
            <li>
              <%= link_to "Help", '#' %>
            </li> 
            <li>
              <%= link_to "Log in", '#' %>
            </li> 
          </ul> 
        </nav> 
      </div> 
    </header> 
    <div class="container"> 
      <%= yield %> 
    </div> 
  </body> 
</html>


# The Home page with a link to the signup page
# app/views/static_pages/home.html.erb
<div class="center jumbotron"> 
  <h1>Welcome to the Sample App</h1> 
  <h2> 
    This is the home page for the 
    <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> sample application. 
  </h2>
  <%= link_to "Sign up now!", '#', class: "btn btn-lg btn-primary" %> 
</div> 
<%= link_to image_tag("rails.png", alt: "Rails logo"), 'http://rubyonrails.org/' %>


# $ curl -O http://rubyonrails.org/images/rails.png
# $ mv rails.png app/assets/images/
$ curl -o app/assets/images/rails.png -OL railstutorial.org/rails.png

http://localhost:3000/

Adding the bootstrap-sass gem to the Gemfile
# gem 'bootstrap-sass', '3.2.0.0'
# https://rubygems.org/gems/bootstrap-sass
# gem 'bootstrap-sass', '~> 3.3', '>= 3.3.6'
# gem 'bootstrap-sass', '~> 3.3'
# Note [Update]
# gem 'bootstrap-sass', '~> 3.3', '>= 3.3.7'
gem 'bootstrap-sass', '~> 3.3'

# Install Bootstrap
$ bundle install

# Custom CSS file
$ touch app/assets/stylesheets/custom.css.scss

# Adding Bootstrap CSS.app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap";

# Restart Server # delete tmp/pids/server.pid

http://localhost:3000/

# Adding CSS for some universal styling applying to all pages
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* universal */ 
body { 
  padding-top: 60px; 
}

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
} 

.center h1 { 
  margin-bottom: 10px; 
}


# Adding CSS for nice typography.app/assets/stylesheets/custom.css.scss
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* universal */ 
body { 
  padding-top: 60px; 
}

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
} 

.center h1 { 
  margin-bottom: 10px; 
}

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
  line-height: 1; 
} 

h1 { 
  font-size: 3em; 
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
}

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: #777; 
} 

p { 
  font-size: 1.1em; 
  line-height: 1.7em; 
}

# Adding CSS for the site logo.app/assets/stylesheets/custom.css.scss
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* universal */ 
body { 
  padding-top: 60px; 
}

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
} 

.center h1 { 
  margin-bottom: 10px; 
}

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
  line-height: 1; 
} 

h1 { 
  font-size: 3em; 
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
}

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: #777; 
} 

p { 
  font-size: 1.1em; 
  line-height: 1.7em; 
}

/* header */ 

#logo { 
  float: left; 
  margin-right: 10px; 
  font-size: 1.7em; 
  color: #fff; 
  text-transform: uppercase; 
  letter-spacing: -1px; 
  padding-top: 9px; 
  font-weight: bold; 
} 

#logo:hover { 
 color: #fff; 
  text-decoration: none; 
}


# The site layout with partials for the stylesheets and header
# app/views/layouts/application.html.erb
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= full_title(yield(:title)) %></title> 
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %> 
    <%= csrf_meta_tags %> 
    <%= render 'layouts/shim' %> 
  </head> 
  <body> 
    <%= render 'layouts/header' %> 
    <div class="container"> 
      <%= yield %> 
    </div> 
  </body> 
</html>

# A partial for the HTML shim
# app/views/layouts/_shim.html.erb
<!--[if lt IE 9]> 
  <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js"> </script> 
<![endif]-->

# A partial for the site header
# app/views/layouts/_header.html.erb
<header class="navbar navbar-fixed-top navbar-inverse"> 
  <div class="container"> 
    <%= link_to "sample app", '#', id: "logo" %>
    <nav> 
      <ul class="nav navbar-nav navbar-right"> 
        <li>
          <%= link_to "Home", '#' %></li> <li><%= link_to "Help", '#' %>
        </li> 
        <li>
          <%= link_to "Log in", '#' %>
        </li> 
      </ul> 
    </nav> 
  </div> 
</header>

# A partial for the site footer
# app/views/layouts/_footer.html.erb
<footer class="footer"> 
  <small> 
    The <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> 
    by <a href="http://www.michaelhartl.com/">Michael Hartl</a> 
  </small> 
  <nav> 
    <ul> 
      <li><%= link_to "About", '#' %></li> 
      <li><%= link_to "Contact", '#' %></li> 
      <li><a href="http://news.railstutorial.org/">News</a></li> 
    </ul> 
  </nav> 
</footer>


# The site layout with a footer partial
# app/views/layouts/application.html.erb
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= full_title(yield(:title)) %></title> 
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %> 
    <%= csrf_meta_tags %> 
    <%= render 'layouts/shim' %> 
  </head> 
  <body> 
    <%= render 'layouts/header' %> 
    <div class="container"> 
      <%= yield %>
      <%= render 'layouts/footer' %>
    </div> 
  </body> 
</html>

# Adding the CSS for the site footer
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* universal */ 
body { 
  padding-top: 60px; 
}

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
} 

.center h1 { 
  margin-bottom: 10px; 
}

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
  line-height: 1; 
} 

h1 { 
  font-size: 3em; 
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
}

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: #777; 
} 

p { 
  font-size: 1.1em; 
  line-height: 1.7em; 
}

/* header */ 

#logo { 
  float: left; 
  margin-right: 10px; 
  font-size: 1.7em; 
  color: #fff; 
  text-transform: uppercase; 
  letter-spacing: -1px; 
  padding-top: 9px; 
  font-weight: bold; 
} 

#logo:hover { 
 color: #fff; 
  text-decoration: none; 
}

/* footer */ 
footer { 
  margin-top: 45px; 
  padding-top: 5px; border-top: 1px solid #eaeaea; color: #777; 
} 

footer a { 
  color: #555; 
} 

footer a:hover { 
  color: #222; 
} 

footer small { 
  float: left; 
} 

footer ul { 
  float: right; list-style: none; 
} 

footer ul li { 
  float: left; margin-left: 15px; 
}

http://localhost:3000/

# The manifest file for app-specific CSS
# The key lines here are actually CSS comments, but they are used by Sprockets to include the proper files:
*= require_tree . /* ensures that all CSS files in the app/assets/stylesheets directory (including the tree subdirectories) are included into the application CSS */
*= require_self   /* specifies where in the loading sequence the CSS in application.css itself gets included */
# app/assets/stylesheets/application.css
/*
 * This is a manifest file that'll be compiled into application.css, which will include all the files
 * listed below.
 *
 * Any CSS and SCSS file within this directory, lib/assets/stylesheets, vendor/assets/stylesheets,
 * or any plugin's vendor/assets/stylesheets directory can be referenced here using a relative path.
 *
 * You're free to add application-wide styles to this file and they'll appear at the bottom of the
 * compiled file so the styles you add here take precedence over styles defined in any styles
 * defined in the other CSS/SCSS files in this directory. It is generally better to create a new
 * file per style scope.
 *
 *= require_tree .
 *= require_self
*/
 

# Preprocessor engines
# Rails which processor to use using filename extensions
# The three most common cases are .scss for Sass, .coffee for CoffeeScript, and .erb for embedded Ruby (ERb)
# The preprocessor engines can be chained, 
# so that foobar.js.coffee 
# gets run through the CoffeeScript processor, and 
# foobar.js.erb.coffee 
# gets run through both CoffeeScript and ERb (with the code running from right to left, i.e., CoffeeScript first)

# Syntactically awesome stylesheets
# The initial SCSS file converted to use nesting and variables
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* mixins, variables, etc. */ 

$gray-medium-light: #eaeaea; 

/* universal */ 

body { 
  padding-top: 60px; 
} 

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
  h1 { 
    margin-bottom: 10px; 
  } 
} 

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
 line-height: 1;
} 

h1 { 
  font-size: 3em;  
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
} 

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: $gray-light; 
} 

p { 
  font-size: 1.1em; line-height: 1.7em; 
} 

/* header */ 

#logo { 
  float: left; 
  margin-right: 10px; 
  font-size: 1.7em; 
  color: white; 
  text-transform: uppercase; 
  letter-spacing: -1px; 
  padding-top: 9px; 
  font-weight: bold; 
  &:hover { 
    color: white; text-decoration: none; 
  } 
} 

/* footer */ 

footer { 
  margin-top: 45px; 
  padding-top: 5px; 
  border-top: 1px solid $gray-medium-light; 
  color: $gray-light; 
  a { 
    color: $gray; 
    &:hover {
      color: $gray-darker; 
    } 
  } 
  small { 
  float: left; 
  } 
  ul { 
    float: right; 
    list-style: none; 
    li { 
      float: left; 
      margin-left: 15px; 
    } 
  } 
}

# Layout links
Page		URL		Named route
Home		/		root_path
About		/about		about_path
Help		/help		help_path
Contact		/contact	contact_path
Sign up		/signup		signup_path
Log in		/login		login_path

# A test for the Contact page
# test/controllers/static_pages_controller_test.rb
require 'test_helper'

class StaticPagesControllerTest < ActionController::TestCase
  test "should get home" do
    get :home
    assert_response :success
    assert_select "title", "Ruby on Rails Tutorial Sample App"
  end

  test "should get help" do
    get :help
    assert_response :success
    assert_select "title", "Help | Ruby on Rails Tutorial Sample App"
  end

  test "should get about" do
    get :about
    assert_response :success
    assert_select "title", "About | Ruby on Rails Tutorial Sample App"
  end

  test "should get contact" do 
    get :contact 
    assert_response :success 
    assert_select "title", "Contact | Ruby on Rails Tutorial Sample App" 
  end
  
end

# RED
$ bundle exec rake test
ActionController::UrlGenerationError: No route matches
4 runs, 6 assertions, 0 failures, 1 errors, 0 skips

# Adding a route for the Contact page
# config/routes.rb

Rails.application.routes.draw do
  root 'static_pages#home'

  get 'static_pages/help'

  get 'static_pages/about'
  
  get 'static_pages/contact'
end

# Adding an action for the Contact page
# app/controllers/static_pages_controller.rb
class StaticPagesController < ApplicationController
  def home
  end

  def help
  end
  
  def about
  end
  
  def contact
  end
end

# The view for the Contact page
$ touch app/views/static_pages/contact.html.erb
# app/views/static_pages/contact.html.erb
<% provide(:title, 'Contact') %> 
<h1>Contact</h1> 
<p> 
  Contact the Ruby on Rails Tutorial about the sample app at the 
  <a href="http://www.railstutorial.org/#contact">contact page</a>. 
</p>

# GREEN
$ bundle exec rake test
4 runs, 8 assertions, 0 failures, 0 errors, 0 skips

# Rails routes
# Routes for static pages.config/routes.rb
# Common convention of using the _path form except when doing redirects, which is the _url form
(This is because the HTTP standard technically requires a full URL after redirects, though in most browsers it will work either way.)
Rails.application.routes.draw do
  root 'static_pages#home'
  
  # get 'static_pages/help'
  get 'help' => 'static_pages#help'

  # get 'static_pages/about'
  get 'about' => 'static_pages#about'
  
  # get 'static_pages/contact'
  get 'contact' => 'static_pages#contact'
end

# Using named routes
# Header partial with links
app/views/layouts/_header.html.erb
<header class="navbar navbar-fixed-top navbar-inverse"> 
  <div class="container"> 
    <%= link_to "sample app", root_path, id: "logo" %>
    <nav> 
      <ul class="nav navbar-nav navbar-right"> 
        <li><%= link_to "Home", root_path %></li> 
        <li><%= link_to "Help", help_path %></li> 
      </ul> 
    </nav> 
  </div> 
</header>

# Footer partial with links
# app/views/layouts/_footer.html.erb
<footer class="footer"> 
  <small> 
    The <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> 
    by <a href="http://www.michaelhartl.com/">Michael Hartl</a> 
  </small> 
  <nav> 
    <ul> 
      <li><%= link_to "About", about_path %></li> 
      <li><%= link_to "Contact", contact_path %></li>
      <li><a href="http://news.railstutorial.org/">News</a></li> 
    </ul> 
  </nav> 
</footer>

http://localhost:3000/about


# Layout link tests
$ rails generate integration_test site_layout


# A test for the links on the layout
# test/integration/site_layout_test.rb
require 'test_helper'

class SiteLayoutTest < ActionDispatch::IntegrationTest
  test "layout links" do
    get root_path 
    assert_template 'static_pages/home' 
    assert_select "a[href=?]", root_path, count: 2 
    assert_select "a[href=?]", help_path 
    assert_select "a[href=?]", about_path 
    assert_select "a[href=?]", contact_path
  end
end

# Uses of assert_select			
Code						Matching HTML
assert_select "div"				<div>foobar</div>
assert_select "div", "foobar"			<div>foobar</div>
assert_select "div.nav"				<div class="nav">foobar</div>
assert_select "div#profile"			<div id="profile">foobar</div>
assert_select "div[name=yo]"			<div name="yo">hey</div>
assert_select "a[href=?]", '/', count: 1	<a href="/">foo</a>
assert_select "a[href=?]", '/', text: "foo"	<a href="/">foo</a>

# Integration tests using the following Rake task
# GREEN
$ bundle exec rake test:integration
1 runs, 5 assertions, 0 failures, 0 errors, 0 skips

# Full test suite to verify that all the tests
# GREEN
$ bundle exec rake test
5 runs, 13 assertions, 0 failures, 0 errors, 0 skips


## 5.4 User signup: A first step

# Users controller
# Generating a Users controller (with a new action)
$ rails generate controller Users new

# GREEN 
$ bundle exec rake test
6 runs, 14 assertions, 0 failures, 0 errors, 0 skips

# Signup URL
# A route for the signup page
# config/routes.rb
Rails.application.routes.draw do 
  root 'static_pages#home'
  
  # get 'static_pages/help'
  get 'help' => 'static_pages#help'

  # get 'static_pages/about'
  get 'about' => 'static_pages#about'
  
  # get 'static_pages/contact'
  get 'contact' => 'static_pages#contact'
  
  # get 'users/new'
  get 'signup' => 'users#new'
end

# Linking the button to the signup page
# app/views/static_pages/home.html.erb
<div class="center jumbotron"> 
  <h1>Welcome to the Sample App</h1> 
  <h2> 
    This is the home page for the 
    <a href="http://www.railstutorial.org/">Ruby on Rails Tutorial</a> 
    sample application. 
  </h2> 
  <%= link_to "Sign up now!", signup_path, class: "btn btn-lg btn-primary" %> 
</div> 

<%= link_to image_tag("rails.png", alt: "Rails logo"), 'http://rubyonrails.org/' %>

# The initial (stub) signup page.app/views/users/new.html.erb
<% provide(:title, 'Sign up') %> 
<h1>Sign up</h1> 
<p>This will be a signup page for new users.</p>

http://localhost:3000/signup

# GREEN
$ bundle exec rake test
6 runs, 14 assertions, 0 failures, 0 errors, 0 skips


## 6 Modeling users
# $ rails generate controller Users new 
# The analogous command for making a model is generate model, which can be used to generate a User model with name and email attributes
$ rails generate model User name:string email:string
# (Note that, in contrast to the plural convention for controller names, model names are singular: a Users controller, but a User model.)

# "migrating up"
$ bundle exec rake db:migrate
#  "migrate down"
# Most migrations are reversible, which means we can "migrate down" and undo them with a single Rake task, called db:rollback:
# $ bundle exec rake db:rollback

# Creating user objects
# Start console in a sandbox (so that no changes are made to the database)
$ rails console --sandbox
# "Any modifications will be rolled back on exit"

# User validations
# A validity test
# The practically blank default User test
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
end

# Note
$ bin/rake db:migrate RAILS_ENV=test
# GREEN 
$ bundle exec rake test:models
1 runs, 1 assertions, 0 failures, 0 errors, 0 skips

# Validating presence
# A test for validation of the name attribute
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end

  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end
end

# RED
$ bundle exec rake test:models
UserTest#test_name_should_be_present
2 runs, 2 assertions, 1 failures, 0 errors, 0 skips

# Validating the presence of a name attribute
# app/models/user.rb
class User < ActiveRecord::Base
  # validates(:name, presence: true)
  validates :name, presence: true
end

$ rails console --sandbox

# GREEN 
$ bundle exec rake test:models
2 runs, 2 assertions, 0 failures, 0 errors, 0 skips

# A test for validation of the email attribute
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end
end

# Validating the presence of an email attribute
# app/models/user.rb
class User < ActiveRecord::Base
  # validates(:name, presence: true)
  validates :name, presence: true
  validates :email, presence: true
end

# GREEN 
$ bundle exec rake test
9 runs, 17 assertions, 0 failures, 0 errors, 0 skips

# Length validation
# A test for name length validation
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end  

  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
end

# RED 
$ bundle exec rake test
UserTest#test_email_should_not_be_too_long
UserTest#test_name_should_not_be_too_long
11 runs, 19 assertions, 2 failures, 0 errors, 0 skips

# Adding a length validation for the name attribute
# app/models/user.rb
class User < ActiveRecord::Base
  validates :name, presence: true, length: { maximum: 50 }
  validates :email, presence: true, length: { maximum: 255 }
end

# GREEN 
$ bundle exec rake test
11 runs, 19 assertions, 0 failures, 0 errors, 0 skips

# Format validation
# Tests for valid email formats
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end
end

# GREEN
$ bundle exec rake test
12 runs, 24 assertions, 0 failures, 0 errors, 0 skips

# Tests for email format validation
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end

  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example. foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end
end

# RED
$ bundle exec rake test
UserTest#test_email_validation_should_reject_invalid_addresses
13 runs, 25 assertions, 1 failures, 0 errors, 0 skips

# VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i

Expression				Meaning
/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i	full regex
/					start of regex
\A					match start of a string
[\w+\-.]+				at least one word character, plus, hyphen, or dot
@					literal "at sign"
[a-z\d\-.]+				at least one letter, digit, hyphen, or dot
\.					literal dot
[a-z]+					at least one letter
\z					match end of a string
/					end of regex
i					case-insensitive


# Rubular interactive regular expression matcher
# http://www.rubular.com/
# Note: If you use the regex as aforementioned (Expression and Meaning) in Rubular, consider leaving off the \A and \z characters in order to match more than one email address at a time in the given test string

# Validating the email format with a regular expression
# app/models/user.rb
class User < ActiveRecord::Base
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }
end

# GREEN 
$ bundle exec rake test:models
13 runs, 29 assertions, 0 failures, 0 errors, 0 skips


# Uniqueness validation
# A test for the rejection of duplicate email addresses
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end

  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example. foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end

  test "email addresses should be unique" do 
    duplicate_user = @user.dup
    @user.save
    assert_not duplicate_user.valid?
  end
end

# RED
$ bundle exec rake test
UserTest#test_email_addresses_should_be_unique
14 runs, 30 assertions, 1 failures, 0 errors, 0 skips

# Validating the uniqueness of email addresses
# app/models/user.rb
class User < ActiveRecord::Base
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: true
end

# GREEN
$ bundle exec rake test
14 runs, 30 assertions, 0 failures, 0 errors, 0 skips

# Testing case-insensitive email uniqueness
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end

  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example. foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end

  test "email addresses should be unique" do 
    duplicate_user = @user.dup
    duplicate_user.email = @user.email.upcase
    @user.save
    assert_not duplicate_user.valid?
  end
end

# RED
$ bundle exec rake test
UserTest#test_email_addresses_should_be_unique
14 runs, 30 assertions, 1 failures, 0 errors, 0 skips

$ rails console --sandbox

# Validating the uniqueness of email addresses, ignoring case
# app/models/user.rb
class User < ActiveRecord::Base
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
end

# GREEN
$ bundle exec rake test
14 runs, 30 assertions, 0 failures, 0 errors, 0 skips

# Box 6.2. Database indices
# Putting an index on the email column
# Adding structure to an existing model, hence create a migration directly using the migration generator
$ rails generate migration add_index_to_users_email

# The migration for enforcing email uniqueness
# db/migrate/[timestamp]_add_index_to_users_email.rb
class AddIndexToUsersEmail < ActiveRecord::Migration 
  def change 
    add_index :users, :email, unique: true 
  end 
end

# Migrate the database
$ bundle exec rake db:migrate
(If this fails, try exiting any running sandbox console sessions, which can lock the database and prevent migrations.)

# The default user fixtures
# test/fixtures/users.yml
# Read about fixtures at http://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html

one:
  name: MyString
  email: MyString

two:
  name: MyString
  email: MyString

# Fixtures not needed now
# Empty fixtures file
# test/fixtures/users.yml
# empty

# Ensuring email uniqueness by downcasing the email attribute
# Preventing a full-table scan when finding users by email address
# app/models/user.rb
class User < ActiveRecord::Base
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
end

[
# A test for the email downcasing
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end
  
  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example. foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end

  test "email addresses should be unique" do 
    duplicate_user = @user.dup
	duplicate_user.email = @user.email.upcase
    @user.save
    assert_not duplicate_user.valid?
  end

  test "email addresses should be saved as lower-case" do
    mixed_case_email = "Foo@ExAMPle.CoM"
    @user.email = mixed_case_email
    @user.save
    assert_equal mixed_case_email.downcase, @user.reload.email
  end
end

An alternate callback implementation
# app/models/user.rb
class User < ActiveRecord::Base
  before_save { email.downcase! }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
end
]

# Adding a secure password
# Hashed password
# Secure password machinery will be implemented using a single Rails method called has_secure_password, included in the User model
"has_secure_password" method adds the following functionality: 
 The ability to save a securely hashed password_digest attribute to the database
 A pair of virtual attributes18 (password and password_confirmation), including presence validations upon object creation and a validation requiring that they match
 An authenticate method that returns the user when the password is correct (andfalse otherwise)
# The only requirement for has_secure_password to work its magic is for the corresponding model to have an attribute called password_digest
# hashed password and password digest are synonyms
# To implement the data model, we first generate an appropriate migration for the password_digest column
# Although any migration name will do, it's convenient to end migration name with to_users
# Since in this case Rails automatically constructs a migration to add columns to the users table
# The result, with migration name add_password_digest_to_users, appears as follows
$ rails generate migration add_password_digest_to_users password_digest:string

# Migrate the database
$ bundle exec rake db:migrate

# Adding bcrypt to the Gemfile
# Use ActiveModel has_secure_password

# gem 'bcrypt', '~> 3.1.7'
# https://rubygems.org/gems/bcrypt
# gem 'bcrypt', '~> 3.1', '>= 3.1.11'
gem 'bcrypt', '~> 3.1.11'

# install
$ bundle show
$ gem list
$ bundle install
$ gem list

# User has secure password
# Adding has_secure_password to the User model
# app/models/user.rb
class User < ActiveRecord::Base
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
end

# Note
$ bin/rake db:migrate RAILS_ENV=test
$ bin/rake db:migrate:status
[
$ bin/rake db:migrate:status

database: E:/Working/Ruby/Ruby On Rails/Learn Web Development with Rails/Third Edition/workspace/sample_app/db/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20160929105616  Create users
   up     20160930144234  Add index to users email
   up     20160930144712  Add password digest to users
]
$ bin/rake db:reset
$ bin/rake db:migrate RAILS_ENV=test

# RED
$ bundle exec rake test
14 runs, 26 assertions, 2 failures, 0 errors, 0 skips

# Adding a password and its confirmation
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com", password: "foobar", password_confirmation: "foobar")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end
  
  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example. foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end

  test "email addresses should be unique" do 
    duplicate_user = @user.dup
	duplicate_user.email = @user.email.upcase
    @user.save
    assert_not duplicate_user.valid?
  end
end

# GREEN 
$ bundle exec rake test
14 runs, 30 assertions, 0 failures, 0 errors, 0 skips

# Minimum password standards
# Testing for a minimum password length
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com", password: "foobar", password_confirmation: "foobar")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end
  
  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example. foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end

  test "email addresses should be unique" do 
    duplicate_user = @user.dup
	duplicate_user.email = @user.email.upcase
    @user.save
    assert_not duplicate_user.valid?
  end

  test "password should be present (nonblank)" do 
    @user.password = @user.password_confirmation = " " * 6 
    assert_not @user.valid? 
  end

  test "password should have a minimum length" do
    @user.password = @user.password_confirmation = "a" * 5
    assert_not @user.valid?
  end
end

# The complete implementation for secure passwords
# app/models/user.rb
class User < ActiveRecord::Base
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }
end

# GREEN 
$ bundle exec rake test:models
10 runs, 18 assertions, 0 failures, 0 errors, 0 skips

# Creating and authenticating a user
# rails console


## 7 Sign up
# Showing users
# Debug and Rails environments
# Adding some debug information to the site layout
# app/views/layouts/application.html.erb
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= full_title(yield(:title)) %></title> 
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %> 
    <%= csrf_meta_tags %> 
    <%= render 'layouts/shim' %> 
  </head> 
  <body> 
    <%= render 'layouts/header' %> 
    <div class="container"> 
      <%= yield %>
      <%= render 'layouts/footer' %>
      <%= debug(params) if Rails.env.development? %>
    </div> 
  </body> 
</html>

# Rails environments Rails
$ rails console

$ rails console test

# As with the console, development is the default environment for the Rails server
# However you can also run it in a different environment: 
$ rails server --environment production 

# If you view your app running in production, it won't work without a production database
# Production database we can create by running rake db:migrate in production: 
$ bundle exec rake db:migrate RAILS_ENV=production

# Adding code for a pretty debug box, including a Sass mixin
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* mixins, variables, etc. */

$gray-medium-light: #eaeaea;

@mixin box_sizing { 
  -moz-box-sizing: border-box; 
  -webkit-box-sizing: border-box; 
  box-sizing: border-box; 
}

/* miscellaneous */

.debug_dump { 
  clear: both; 
  float: left; 
  width: 100%; 
  margin-top: 45px; 
  @include box_sizing; 
}
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* mixins, variables, etc. */ 

$gray-medium-light: #eaeaea;

@mixin box_sizing { 
  -moz-box-sizing: border-box; 
  -webkit-box-sizing: border-box; 
  box-sizing: border-box; 
}

/* universal */ 

body { 
  padding-top: 60px; 
} 

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
  h1 { 
    margin-bottom: 10px; 
  } 
} 

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
 line-height: 1;
} 

h1 { 
  font-size: 3em;  
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
} 

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: $gray-light; 
} 

p { 
  font-size: 1.1em; line-height: 1.7em; 
} 

/* header */ 

#logo { 
  float: left; 
  margin-right: 10px; 
  font-size: 1.7em; 
  color: white; 
  text-transform: uppercase; 
  letter-spacing: -1px; 
  padding-top: 9px; 
  font-weight: bold; 
  &:hover { 
    color: white; text-decoration: none; 
  } 
} 

/* footer */ 

footer { 
  margin-top: 45px; 
  padding-top: 5px; 
  border-top: 1px solid $gray-medium-light; 
  color: $gray-light; 
  a { 
    color: $gray; 
    &:hover {
      color: $gray-darker; 
    } 
  } 
  small { 
  float: left; 
  } 
  ul { 
    float: right; 
    list-style: none; 
    li { 
      float: left; 
      margin-left: 15px; 
    } 
  } 
}

/* miscellaneous */

.debug_dump { 
  clear: both; 
  float: left; 
  width: 100%; 
  margin-top: 45px; 
  @include box_sizing; 
}

# A Users resource
$ rails console

# Adding a Users resource to the routes file
# config/routes.rb
Rails.application.routes.draw do
  root 'static_pages#home'
  
  # get 'static_pages/help'
  get 'help' => 'static_pages#help'

  # get 'static_pages/about'
  get 'about' => 'static_pages#about'
  
  # get 'static_pages/contact'
  get 'contact' => 'static_pages#contact'
  
  # get 'users/new'
  get 'signup' => 'users#new'
  
  resources :users
end

Users a fully RESTful resource.
HTTP request		URL		Action		Named route		Purpose
GET			/users		index		users_path		page to list all users
GET			/users/1	show		user_path(user)		page to show user
GET			/users/new	new		new_user_path		page to make a new user (signup)
POST			/users		create		users_path		create a new user
GET			/users/1/edit	edit		edit_user_path(user)	page to edit user with id 1
PATCH			/users/1	update		user_path(user)		update user
DELETE			/users/1	destroy		user_path(user)		delete user

# A stub view for showing user information
# app/views/users/show.html.erb
<%= @user.name %>, <%= @user.email %>

# The Users controller with a show action
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id]) 
  end

  def new
  end
end

# User.find(params[:id])
# action: 
# show controller: users 
# id: '1'
http://localhost:3000/users/1
--- !ruby/hash:ActionController::Parameters
controller: users
action: show
id: '1'

# Debugger
# The Users controller with a debugger
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
    debugger
  end
  
  def new
  end
end

[
E:\Working\Ruby\Ruby On Rails\Learn Web Development with Rails\Third Edition\workspace\sample_app\Gemfile
 
group :development, :test do
  # Call 'byebug' anywhere in the code to stop execution and get a debugger console
  # gem 'byebug'
  # gem 'byebug', github: 'deivid-rodriguez/byebug', branch: 'master'
  # https://rubygems.org/gems/byebug
  # gem 'byebug', '~> 9.0', '>= 9.0.5'
  # gem 'byebug', '~> 9.0'
  # Note [Update]
  # gem 'byebug', '~> 9.0', '>= 9.0.6'
  gem 'byebug', '~> 9.0'
end
]

http://localhost:3000/users/1

# Rails server shows a byebug prompt:
[1, 9] in E:/Working/Ruby/Ruby On Rails/Learn Web Development with Rails/Third Edition/workspace/sample_app/app/controllers/users_controller.rb
   1: class UsersController < ApplicationController
   2:   def show
   3:     @user = User.find(params[:id])
   4:   debugger
=> 5:   end
   6:
   7:   def new
   8:   end
   9: end
(byebug)

[
(byebug) @user.name 
"Example User" 
(byebug) 
@user.email 
"example@railstutorial.org" 
(byebug) params[:id] "1"

# To release the prompt and continue execution of the application 
# Press Ctrl-D, then remove the debugger line from the show action
]

# The Users controller with a debugger removed
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
  end
end

# A Gravatar image and a sidebar
# The user show view with name and Gravatar
# app/views/users/show.html.erb
<% provide(:title, @user.name) %> 
<h1> 
  <%= gravatar_for @user %> 
  <%= @user.name %> 
</h1>

# Defining a gravatar_for helper method
# app/helpers/users_helper.rb
module UsersHelper
  # Returns the Gravatar for the given user. 
  def gravatar_for(user)
    gravatar_id = Digest::MD5::hexdigest(user.email.downcase) 
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}"   
    image_tag(gravatar_url, alt: user.name, class: "gravatar") 
  end
end

http://localhost:3000/users/1

$ rails console 
>> user = User.first 
>> user.update_attributes(name: "Example User", email: "example@railstutorial.org", password: "foobar", password_confirmation: "foobar")
=> true
>> exit

# Adding a sidebar to the user show view
# app/views/users/show.html.erb
<% provide(:title, @user.name) %>
<div class="row"> 
  <aside class="col-md-4"> 
    <section class="user_info"> 
      <h1>
        <%= gravatar_for @user %> 
        <%= @user.name %> 
      </h1> 
    </section> 
  </aside> 
</div>

# SCSS for styling the user show page, including the sidebar
.
.
.
/* sidebar */ 
aside { 
  section.user_info { 
    margin-top: 20px; 
  } 
  section { 
    padding: 10px 0; 
    margin-top: 20px; 
    &:first-child { 
      border: 0; 
      padding-top: 0; 
    } 
    span { 
      display: block; 
      margin-bottom: 3px; 
      line-height: 1; 
    } 
    h1 { 
      font-size: 1.4em; 
      text-align: left; 
      letter-spacing: -1px; 
      margin-bottom: 3px; 
      margin-top: 0px; 
    } 
  } 
} 

.gravatar { 
  float: left; 
  margin-right: 10px; 
} 
  
.gravatar_edit { 
  margin-top: 15px; 
}
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* mixins, variables, etc. */ 

$gray-medium-light: #eaeaea;

@mixin box_sizing { 
  -moz-box-sizing: border-box; 
  -webkit-box-sizing: border-box; 
  box-sizing: border-box; 
}

/* universal */ 

body { 
  padding-top: 60px; 
} 

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
  h1 { 
    margin-bottom: 10px; 
  } 
} 

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
 line-height: 1;
} 

h1 { 
  font-size: 3em;  
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
} 

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: $gray-light; 
} 

p { 
  font-size: 1.1em; line-height: 1.7em; 
} 

/* header */ 

#logo { 
  float: left; 
  margin-right: 10px; 
  font-size: 1.7em; 
  color: white; 
  text-transform: uppercase; 
  letter-spacing: -1px; 
  padding-top: 9px; 
  font-weight: bold; 
  &:hover { 
    color: white; text-decoration: none; 
  } 
} 

/* footer */ 

footer { 
  margin-top: 45px; 
  padding-top: 5px; 
  border-top: 1px solid $gray-medium-light; 
  color: $gray-light; 
  a { 
    color: $gray; 
    &:hover {
      color: $gray-darker; 
    } 
  } 
  small { 
  float: left; 
  } 
  ul { 
    float: right; 
    list-style: none; 
    li { 
      float: left; 
      margin-left: 15px; 
    } 
  } 
}

/* miscellaneous */

.debug_dump { 
  clear: both; 
  float: left; 
  width: 100%; 
  margin-top: 45px; 
  @include box_sizing; 
}

/* sidebar */ 
aside { 
  section.user_info { 
    margin-top: 20px; 
  } 
  section { 
    padding: 10px 0; 
    margin-top: 20px; 
    &:first-child { 
      border: 0; 
      padding-top: 0; 
    } 
    span { 
      display: block; 
      margin-bottom: 3px; 
      line-height: 1; 
    } 
    h1 { 
      font-size: 1.4em; 
      text-align: left; 
      letter-spacing: -1px; 
      margin-bottom: 3px; 
      margin-top: 0px; 
    } 
  } 
} 

.gravatar { 
  float: left; 
  margin-right: 10px; 
} 
  
.gravatar_edit { 
  margin-top: 15px; 
}

http://localhost:3000/users/1

# Signup form

# To add the ability to create new users through the web, remove the user created at the console
# The cleanest way to do this is to reset the database with the db:migrate:reset Rake task: 
# $ bundle exec rake db:migrate:reset # db/development.sqlite3 already exists
$ bin/rake db:reset

# Adding an @user variable to the new action
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
end

# A form to sign up new users
# app/views/users/new.html.erb
<% provide(:title, 'Sign up') %> 
<h1>Sign up</h1>

<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(@user) do |f| %> 
      <%= f.label :name %>
      <%= f.text_field :name %> 
      <%= f.label :email %> 
      <%= f.email_field :email %> 
      <%= f.label :password %> 
      <%= f.password_field :password %> 
      <%= f.label :password_confirmation, "Confirmation" %> 
      <%= f.password_field :password_confirmation %>
      <%= f.submit "Create my account", class: "btn btn-primary" %> 
    <% end %> 
  </div> 
</div>

# CSS for the signup form
# app/assets/stylesheets/custom.css.scss
. 
. 
. 
/* forms */

input, textarea, select, .uneditable-input { 
  border: 1px solid #bbb; 
  width: 100%; 
  margin-bottom: 15px; 
  @include box_sizing; 
} 

input { 
  height: auto !important; 
}

http://localhost:3000/signup

# Unsuccessful signups
# A create action that can handle signup failure
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end

  def create 
    @user = User.new(params[:user]) # Not the final implementation! 
    if @user.save 
      # Handle a successful save. 
    else 
      render 'new' 
    end 
  end
end

http://localhost:3000/signup
# Submit the form with some invalid signup data

# Strong parameters
# Using strong parameters in the create action
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
      # Handle a successful save.
    else 
      render 'new' 
    end 
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end
end

# Signup error messages

$ rails console 
>> user = User.new(name: "Foo Bar", email: "foo@invalid", password: "dude", password_confirmation: "dude") 
>> user.save 
=> false 
>> user.errors.full_messages
=> ["Email is invalid", "Password is too short (minimum is 6 characters)"]
>> exit

# Code to display error messages on the signup form
# app/views/users/new.html.erb
<% provide(:title, 'Sign up') %> 
<h1>Sign up</h1>

<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(@user) do |f| %>
    <%= render 'shared/error_messages' %>
      <%= f.label :name %>
      <%= f.text_field :name, class: 'form-control' %>
      <%= f.label :email %> 
      <%= f.email_field :email, class: 'form-control' %>
      <%= f.label :password %> 
      <%= f.password_field :password, class: 'form-control' %> 
      <%= f.label :password_confirmation, "Confirmation" %> 
      <%= f.password_field :password_confirmation, class: 'form-control' %>
      <%= f.submit "Create my account", class: "btn btn-primary" %> 
    <% end %> 
  </div> 
</div>

$ mkdir app/views/shared
$ touch app/views/shared/_error_messages.html.erb

# A partial for displaying form submission error messages
# app/views/shared/_error_messages.html.erb
<% if @user.errors.any? %> 
  <div id="error_explanation"> 
    <div class="alert alert-danger"> 
      The form contains <%= pluralize(@user.errors.count, "error") %>. 
    </div> 
    <ul> 
      <% @user.errors.full_messages.each do |msg| %> 
      <li><%= msg %></li> 
      <% end %> 
    </ul> 
  </div> 
<% end %>

# CSS for styling error messages
. 
. 
. 
/* forms */ 
. 
. 
. 
#error_explanation { 
  color: red; ul { 
  color: red;
  margin: 0 0 30px 0; 
  } 
} 

.field_with_errors { 
  @extend .has-error; 
  .form-control { 
    color: $state-danger-text;
   } 
}
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* mixins, variables, etc. */ 

$gray-medium-light: #eaeaea;

@mixin box_sizing { 
  -moz-box-sizing: border-box; 
  -webkit-box-sizing: border-box; 
  box-sizing: border-box; 
}

/* universal */ 

body { 
  padding-top: 60px; 
} 

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
  h1 { 
    margin-bottom: 10px; 
  } 
} 

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
 line-height: 1;
} 

h1 { 
  font-size: 3em;  
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
} 

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: $gray-light; 
} 

p { 
  font-size: 1.1em; line-height: 1.7em; 
} 

/* header */ 

#logo { 
  float: left; 
  margin-right: 10px; 
  font-size: 1.7em; 
  color: white; 
  text-transform: uppercase; 
  letter-spacing: -1px; 
  padding-top: 9px; 
  font-weight: bold; 
  &:hover { 
    color: white; text-decoration: none; 
  } 
} 

/* footer */ 

footer { 
  margin-top: 45px; 
  padding-top: 5px; 
  border-top: 1px solid $gray-medium-light; 
  color: $gray-light; 
  a { 
    color: $gray; 
    &:hover {
      color: $gray-darker; 
    } 
  } 
  small { 
  float: left; 
  } 
  ul { 
    float: right; 
    list-style: none; 
    li { 
      float: left; 
      margin-left: 15px; 
    } 
  } 
}

/* miscellaneous */

.debug_dump { 
  clear: both; 
  float: left; 
  width: 100%; 
  margin-top: 45px; 
  @include box_sizing; 
}

/* sidebar */ 
aside { 
  section.user_info { 
    margin-top: 20px; 
  } 
  section { 
    padding: 10px 0; 
    margin-top: 20px; 
    &:first-child { 
      border: 0; 
      padding-top: 0; 
    } 
    span { 
      display: block; 
      margin-bottom: 3px; 
      line-height: 1; 
    } 
    h1 { 
      font-size: 1.4em; 
      text-align: left; 
      letter-spacing: -1px; 
      margin-bottom: 3px; 
      margin-top: 0px; 
    } 
  } 
} 

.gravatar { 
  float: left; 
  margin-right: 10px; 
} 
  
.gravatar_edit { 
  margin-top: 15px; 
}

/* forms */

input, textarea, select, .uneditable-input { 
  border: 1px solid #bbb; 
  width: 100%; 
  margin-bottom: 15px; 
  @include box_sizing; 
} 

input { 
  height: auto !important; 
}

#error_explanation { 
  color: red; ul { 
  color: red;
  margin: 0 0 30px 0; 
  } 
} 

.field_with_errors { 
  @extend .has-error; 
  .form-control { 
    color: $state-danger-text;
   } 
}

http://localhost:3000/signup

# A test for invalid submission
$ rails generate integration_test users_signup
$ rails console 
>> User.count 
=> 0
exit

# A test for an invalid signup
# test/integration/users_signup_test.rb
require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest
  test "invalid signup information" do
    get signup_path 
    assert_no_difference 'User.count' do 
      post users_path, user: { name: "", email: "user@invalid", password: "foo",   password_confirmation: "bar" } 
    end 
    assert_template 'users/new'
  end
end

# Note
$ bin/rake db:migrate RAILS_ENV=test
# GREEN 
$ bundle exec rake test
17 runs, 34 assertions, 0 failures, 0 errors, 0 skips

# Successful signups
# The user create action with a save and a redirect
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
      # Handle a successful save.
      redirect_to @user
    else 
      render 'new' 
    end 
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end
end

# Note
# redirect_to @user is equivalent to redirect_to user_url(@user) 
# However Rails automatically infers from redirect_to @user to redirect to user_url(@user)

# Flash
# Adding a flash message to user signup
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end
end


$ rails console 
>> flash = { success: "It worked!", danger: "It failed." }
=> {:success=>"It worked!", danger: "It failed."} 
>> flash.each do |key, value| puts "#{key}"; puts "#{value}"; end
# OR
flash.each do |key, value|
  puts "#{key}"
  puts "#{value}" 
end 
=>
success
It worked!
danger
It failed.
{:success=>"It worked!", :danger=>"It failed."}
>> exit

# Adding the contents of the flash variable to the site layout
<% flash.each do |message_type, message| %> 
  <div class="alert alert-<%= message_type %>">
   <%= message %>
  </div> 
<% end %>
# app/views/layouts/application.html.erb
<!DOCTYPE html> 
<html> 
  <head> 
    <title><%= full_title(yield(:title)) %></title> 
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' => true %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %> 
    <%= csrf_meta_tags %> 
    <%= render 'layouts/shim' %> 
  </head> 
  <body> 
    <%= render 'layouts/header' %> 
    <div class="container">
      <% flash.each do |message_type, message| %> 
        <div class="alert alert-<%= message_type %>">
          <%= message %>
        </div> 
      <% end %>
      <%= yield %>
      <%= render 'layouts/footer' %>
      <%= debug(params) if Rails.env.development? %>
    </div> 
  </body> 
</html>

# Note
# Bootstrap/Rails - Adding 'close' to flash notice
<% flash.each do |message_type, message| %> 
  <div class="alert alert-<%= message_type %>">
    <button type="button" class="close" data-dismiss="alert" aria-label="Close">x</button>
    <%= message %>
  </div> 
<% end %>
# sanitize
<%= sanitize(message) %>

This will render the link in

http://localhost:3000/signup
Name
Rails Tutorial
Email
example@railstutorial.org
Password
RubyonRails # NOTE: foobar
Confirmation
RubyonRails # NOTE: foobar

$ rails console 
>> User.find_by(email: "example@railstutorial.org")
=> #<User id: 1, name: "Rails Tutorial", email: "example@railstutorial.org", created_at: "2016-10-03 06:24:43", updated_at: "2016-10-03 06:24:43", password_digest: "$2a$10$jWsGzUfSk0TVqlUXOPafPOpVqPjgQK8sqWb7.L4Ytj8...">
>> exit

# A test for valid submission
# A test for a valid signup
# test/integration/users_signup_test.rb
require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest
  test "invalid signup information" do
    get signup_path 
    assert_no_difference 'User.count' do 
      post users_path, user: { name: "", email: "user@invalid", password: "foo",   password_confirmation: "bar" } 
    end 
    assert_template 'users/new'
  end

  test "valid signup information" do
    get signup_path 
    assert_difference 'User.count', 1 do 
      post_via_redirect users_path, user: { name: "Example User", email: "user@example.com", password: "password", password_confirmation: "password" }
    end 
    assert_template 'users/show'
  end
end

# GREEN
$ bundle exec rake test
18 runs, 36 assertions, 0 failures, 0 errors, 0 skips

[
# Professional-grade deployment

# Configuring the application to use SSL in production
# config/environments/production.rb
Rails.application.configure do
  . 
  . 
  . 
  # Force all access to the app over SSL, use Strict-Transport-Security, # and use secure cookies. 
  config.force_ssl = true 
  . 
  . 
  . 
end

# Production webserver
# Adding Puma to the Gemfile
source 'https://rubygems.org' 
. 
. 
. 
group :production do 
  gem 'pg', '0.17.1' 
  gem 'rails_12factor', '0.0.2' 
  gem 'puma', '2.11.1' 
end

$ bundle install

# The configuration file for the production webserver
# config/puma.rb
workers Integer(ENV['WEB_CONCURRENCY'] || 2) 
threads_count = Integer(ENV['MAX_THREADS'] || 5) 
threads threads_count, threads_count 

preload_app! 

rackup DefaultRackup 
port ENV['PORT'] || 3000 
environment ENV['RACK_ENV'] || 'development' 

on_worker_boot do 
  # Worker specific setup for Rails 4.1+ 
  # See: https://devcenter.heroku.com/articles/ 
  # deploying-rails-applications-with-the-puma-web-server#on-worker-boot 
  ActiveRecord::Base.establish_connection 
end

# Defining a Procfile for Puma../Procfile 
web: bundle exec puma -C config/puma.rb

$ bundle exec rake test

# Ruby version number
# To set your Ruby version add this line to your Gemfile: ruby '2.1.5'

]


## 8 Log in, log out Now
# Sessions
# HTTP is a stateless protocol, treating each request as an independent transaction that is unable to use information from any previous requests
# Web applications requiring user login must use a session, which is a semi-permanent connection between two computers (such as a client computer running a web browser and a server running Rails)
# The most common techniques for implementing sessions in Rails involve using cookies, which are small pieces of text placed on the user's browser
# Because cookies persist from one page to the next, they can store information (such as a user id) that can be used by the application to retrieve the logged-in user from the database
# It's convenient to model sessions as a RESTful resource: visiting the login page will render a form for new sessions, logging in will create a session, and logging out will destroy it

# Sessions controller
# The elements of logging in and out correspond to particular REST actions of the Sessions controller: the login form is handled by the new action (covered in this section), actually logging in is handled by sending a POST request to the create action (Section 8.2), and logging out is handled by sending a DELETE request to the destroy action
# Generate a Sessions controller with a new action: 
$ rails generate controller Sessions new
# Including new actually generates views as well, which is why there's no need to include actions likecreate and delete that don't correspond to views

# Adding a resource to get the standard RESTful actions for sessions
# config/routes.rb
Rails.application.routes.draw do
  get 'sessions/new'

  root 'static_pages#home'
  
  # get 'static_pages/help'
  get 'help' => 'static_pages#help'

  # get 'static_pages/about'
  get 'about' => 'static_pages#about'
  
  # get 'static_pages/contact'
  get 'contact' => 'static_pages#contact'
  
  # get 'users/new'
  get 'signup' => 'users#new'
  
  get 'login' => 'sessions#new' 
  post 'login' => 'sessions#create' 
  delete 'logout' => 'sessions#destroy'

  resources :users
end

# The aforementioned routes correspond to URLs and actions
HTTP request	URL	Named route	Action	Purpose
GET		/login	login_path	new	page for a new session (login)
POST		/login	login_path	create	create a new session (login)
DELETE		/logout	logout_path	destroy	delete a session (log out)

# List the routes for the application using rake routes:
$ bundle exec rake routes
      Prefix Verb   URI Pattern               Controller#Action
sessions_new GET    /sessions/new(.:format)   sessions#new
        root GET    /                         static_pages#home
        help GET    /help(.:format)           static_pages#help
       about GET    /about(.:format)          static_pages#about
     contact GET    /contact(.:format)        static_pages#contact
      signup GET    /signup(.:format)         users#new
       login GET    /login(.:format)          sessions#new
             POST   /login(.:format)          sessions#create
      logout DELETE /logout(.:format)         sessions#destroy
       users GET    /users(.:format)          users#index
             POST   /users(.:format)          users#create
    new_user GET    /users/new(.:format)      users#new
   edit_user GET    /users/:id/edit(.:format) users#edit
        user GET    /users/:id(.:format)      users#show
             PATCH  /users/:id(.:format)      users#update
             PUT    /users/:id(.:format)      users#update
             DELETE /users/:id(.:format)      users#destroy


$ Login form
# Code for the login form
# app/views/sessions/new.html.erb
<% provide(:title, "Log in") %> 
<h1>Log in</h1> 
<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(:session, url: login_path) do |f| %> 
      <%= f.label :email %> <%= f.email_field :email, class: 'form-control' %> 
      <%= f.label :password %> <%= f.password_field :password, class: 'form-control' %> 
      <%= f.submit "Log in", class: "btn btn-primary" %> 
    <% end %>
    <p>New user? <%= link_to "Sign up now!", signup_path %></p> 
  </div> 
</div>

http://localhost:3000/login

# Finding and authenticating a user
# A preliminary version of the Sessions create action
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def new
  end

  def create
    render 'new'
  end

  def destroy
  end
end

# Finding and authenticating a user
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      # Log the user in and redirect to the user's show page.
    else 
      # Create an error message. 
      render 'new' 
    end
  end

  def destroy
  end
end
# This uses && (logical and) to determine if the resulting user is valid. Taking into account that any object other than nil and false itself is true in a boolean context (Section 4.2.3), the following possibilities that the if statement is true only if a user with the given email both exists in the database and has the given password, exactly as required
# Possible results of user && user.authenticate
User		Password	a && b
nonexistent	anything	(nil && [anything]) == false
valid user	wrong password	(true && false) == false
valid user	right password	(true && true) == true

# Rendering with a flash message
# An (unsuccessful) attempt at handling failed login
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      # Log the user in and redirect to the user's show page. 
    else 
      flash[:danger] = 'Invalid email/password combination' # Not quite right! 
      render 'new' 
    end 
  end

  def destroy
  end
end

# A flash test
$ rails generate integration_test users_login

# A test to catch unwanted flash persistence
# test/integration/users_login_test.rb
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest  
  test "login with invalid information" do 
    get login_path 
    assert_template 'sessions/new' 
    post login_path, session: { email: "", password: "" } 
    assert_template 'sessions/new' 
    assert_not flash.empty? 
    get root_path 
    assert flash.empty? 
  end
end

# RED 
$ bundle exec rake test TEST=test/integration/users_login_test.rb
UsersLoginTest#test_login_with_invalid_information
1 runs, 4 assertions, 1 failures, 0 errors, 0 skips

# Correct code for failed login
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      # Log the user in and redirect to the user's show page. 
    else 
      flash.now[:danger] = 'Invalid email/password combination' 
      render 'new' 
    end 
  end

  def destroy
  end
end

# GREEN 
$ bundle exec rake test TEST=test/integration/users_login_test.rb 
1 runs, 4 assertions, 0 failures, 0 errors, 0 skips

$ bundle exec rake test
20 runs, 41 assertions, 0 failures, 0 errors, 0 skips

# Logging in
# Including the Sessions helper module into the Application controller
# app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
  # Prevent CSRF attacks by raising an exception.
  # For APIs, you may want to use :null_session instead.
  protect_from_forgery with: :exception
  include SessionsHelper
end

# log_in method
# The log_in function
# app/helpers/sessions_helper.rb
module SessionsHelper
  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end
end

# Logging in a user
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      log_in user 
      redirect_to user
    else 
      flash.now[:danger] = 'Invalid email/password combination' 
      render 'new' 
    end 
  end

  def destroy
  end
end

# Current user
if @current_user.nil? 
  @current_user = User.find_by(id: session[:user_id]) 
else 
  @current_user
end
# OR 
# or operator ||
@current_user = @current_user || User.find_by(id: session[:user_id])

# Finding the current user in the session
# app/helpers/sessions_helper.rb
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Returns the current logged-in user (if any).
  def current_user 
    @current_user ||= User.find_by(id: session[:user_id])
  end
end

# Changing the layout links
# The logged_in? helper method
# app/helpers/sessions_helper.rb
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Returns the current logged-in user (if any).
  def current_user 
    @current_user ||= User.find_by(id: session[:user_id])
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end
end

# Changing the layout links for logged-in users
# app/views/layouts/_header.html.erb
<header class="navbar navbar-fixed-top navbar-inverse"> 
  <div class="container"> 
    <%= link_to "sample app", root_path, id: "logo" %>
    <nav> 
      <ul class="nav navbar-nav navbar-right"> 
        <li><%= link_to "Home", root_path %></li> 
        <li><%= link_to "Help", help_path %></li> 
        <% if logged_in? %> 
          <li><%= link_to "Users", '#' %></li> 
          <li class="dropdown"> 
            <a href="#" class="dropdown-toggle" data-toggle="dropdown"> Account <b class="caret"></b> </a> 
            <ul class="dropdown-menu">               
              <li><%= link_to "Profile", current_user %></li> 
              <li><%= link_to "Settings", '#' %></li> 
              <li class="divider"></li> 
              <li> <%= link_to "Log out", logout_path, method: "delete" %> </li> 
            </ul> 
          </li> 
        <% else %> 
          <li><%= link_to "Log in", login_path %></li> 
        <% end %>  
      </ul> 
    </nav> 
  </div> 
</header>

# Adding the Bootstrap JavaScript library to application.js
# app/assets/javascripts/application.js
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require turbolinks
//= require_tree .

http://localhost:3000/login
Email
example@railstutorial.org
Password
RubyonRails # NOTE: foobar

# Testing layout changes
# Adding a digest method for use in fixtures
# app/models/user.rb
class User < ActiveRecord::Base
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
end

# A fixture for testing user login
# test/fixtures/users.yml
michael: 
  name: Michael Example 
  email: michael@example.com 
  password_digest: <%= User.digest('password') %>

# A test for user logging in with valid information
# test/integration/users_login_test.rb
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest

  def setup 
    @user = users(:michael) 
  end

  test "login with invalid information" do 
    get login_path 
    assert_template 'sessions/new' 
    post login_path, session: { email: "", password: "" } 
    assert_template 'sessions/new' 
    assert_not flash.empty? 
    get root_path 
    assert flash.empty? 
  end

  test "login with valid information" do 
    get login_path 
    post login_path, session: { email: @user.email, password: 'password' } 
    assert_redirected_to @user 
    follow_redirect! 
    assert_template 'users/show' 
    assert_select "a[href=?]", login_path, count: 0 
    assert_select "a[href=?]", logout_path 
    assert_select "a[href=?]", user_path(@user)
  end
end

# GREEN
$ bundle exec rake test TEST=test/integration/users_login_test.rb TESTOPTS="--name test_login_with_valid_information"
1 runs, 6 assertions, 0 failures, 0 errors, 0 skips
# This shows how to run a specific test within a test file by passing the option TESTOPTS="--name test_login_with_valid_information" containing the name of the test
# (A test's name is just the word "test" and the words in the test description joined using underscores.)

# Login upon signup
# Logging in the user upon signup
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
	# debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end
end

# A boolean method for login status inside tests
# test/test_helper.rb
ENV['RAILS_ENV'] ||= 'test'
require File.expand_path('../../config/environment', __FILE__)
require 'rails/test_help'

class ActiveSupport::TestCase
  # Setup all fixtures in test/fixtures/*.yml for all tests in alphabetical order.
  fixtures :all

  # Returns true if a test user is logged in. 
  def is_logged_in? 
    !session[:user_id].nil? 
  end
end

# A test of login after signup # assert is_logged_in?
# test/integration/users_signup_test.rb
require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest
  test "invalid signup information" do
    get signup_path 
    assert_no_difference 'User.count' do 
      post users_path, user: { name: "", email: "user@invalid", password: "foo",   password_confirmation: "bar" } 
    end 
    assert_template 'users/new'
  end
  
  test "valid signup information" do
    get signup_path 
    assert_difference 'User.count', 1 do 
      post_via_redirect users_path, user: { name: "Example User", email: "user@example.com", password: "password", password_confirmation: "password" }
    end 
    assert_template 'users/show'
    assert is_logged_in?
  end
end

# GREEN 
$ bundle exec rake test
21 runs, 48 assertions, 0 failures, 0 errors, 0 skips

# Logging out
# The log_out method
# app/helpers/sessions_helper.rb
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Returns the current logged-in user (if any).
  def current_user 
    @current_user ||= User.find_by(id: session[:user_id])
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Logs out the current user.
  def log_out 
    session.delete(:user_id) 
    @current_user = nil
  end
end

# Destroying a session (user logout)
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      log_in user
      redirect_to user
    else 
      flash.now[:danger] = 'Invalid email/password combination' 
      render 'new' 
    end 
  end

  def destroy
    log_out 
    redirect_to root_url
  end
end

# A test for user logout
# test/integration/users_login_test.rb
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest

  def setup 
    @user = users(:michael) 
  end

  test "login with invalid information" do 
    get login_path 
    assert_template 'sessions/new' 
    post login_path, session: { email: "", password: "" } 
    assert_template 'sessions/new' 
    assert_not flash.empty? 
    get root_path 
    assert flash.empty? 
  end

  test "login with valid information" do 
    get login_path 
    post login_path, session: { email: @user.email, password: 'password' } 
    assert_redirected_to @user 
    follow_redirect! 
    assert_template 'users/show' 
    assert_select "a[href=?]", login_path, count: 0 
    assert_select "a[href=?]", logout_path 
    assert_select "a[href=?]", user_path(@user)
  end

  test "login with valid information followed by logout" do 
    get login_path 
    post login_path, session: { email: @user.email, password: 'password' } 
    assert is_logged_in? 
    assert_redirected_to @user 
    follow_redirect! 
    assert_template 'users/show' 
    assert_select "a[href=?]", login_path, count: 0 
    assert_select "a[href=?]", logout_path 
    assert_select "a[href=?]", user_path(@user) 
    delete logout_path 
    assert_not is_logged_in? 
    assert_redirected_to root_url 
    follow_redirect!       
    assert_select "a[href=?]", login_path 
    assert_select "a[href=?]", logout_path, count: 0 
    assert_select "a[href=?]", user_path(@user), count: 0 
  end
end

# GREEN 
$ bundle exec rake test
22 runs, 60 assertions, 0 failures, 0 errors, 0 skips

# Remember me
# The login system (used above) is self-contained and fully functional, however most websites have the additional capability of remembering users' sessions even after closing the browsers
# 1. Remembering user logins by default, expiring the sessions only when users explicitly log out
# 2. Common alternative model, a "remember me" checkbox that allows users to opt out of being remembered
# Both of these models are professional-grade, with the first used by sites such as GitHub and Bitbucket, and the second used by sites such as Facebook and Twitter.

# Remember token and digest
# Rails session method (used above) to store the user's id, however this information disappears when the user closes the browser
# First step toward persistent sessions by generating a remember token appropriate for creating permanent cookies using the cookies method, together with a secure remember digest for authenticating those tokens
# Information stored using session is automatically secure, however this is not the case with information stored using cookies
# Persistent cookies are vulnerable to session hijacking, in which an attacker uses a stolen remember token to log in as a particular user.
# There are four main ways to steal cookies: 
(1) Using a packet sniffer to detect cookies being passed over insecure networks
(2) Compromising a database containing remember tokens
(3) Using cross-site scripting (XSS)
(4) Gaining physical access to a machine with a logged-in user
# Prevention
(1) [The first problem is prevented by using Secure Sockets Layer (SSL) site-wide (config/environments/production.rb), which protects network data from packet sniffers]
(2) The second problem by storing a hash digest of the remember token instead of the token itself, in much the same way that we stored password digests instead of raw passwords
(3) Rails automatically prevents the third problem by escaping any content inserted into view templates
(4) Finally, although there's no iron-clad way to stop attackers who have physical access to a logged-in computer, we'll minimize the fourth problem by changing tokens every time a user logs out and by taking care tocryptographically sign any potentially sensitive information we place on the browser.

# Adding the required remember_digest attribute to the User model
$ rails generate migration add_remember_digest_to_users remember_digest:string

# The generated migration for the remember digest
# db/migrate/[timestamp]_add_remember_digest_to_users.rb
class AddRememberDigestToUsers < ActiveRecord::Migration
  def change
    add_column :users, :remember_digest, :string
  end
end
# Because it is not expected to retrieve users by remember digest, there's no need to put an index on the remember_digest column, and the default migration can be used as generated: 
$ bundle exec rake db:migrate

# In case of remember token, there are many mostly equivalent possibilitiesessentially, any long random string will do. # The urlsafe_base64 method from the SecureRandom module in the Ruby standard library fits the bill, it returns a random string of length 22 composed of the characters AZ, az, 09, "-", and "_" (for a total of 64 possibilities, thus "base64")
# A typical base64 string appears as follows:
$ rails console 
>> SecureRandom.urlsafe_base64
=> "cvMiaDvQa15uZlJtRARKXQ"
>> exit

# Just as it's perfectly fine if two users have the same password, 16 there's no need for remember tokens to be unique, however it's more secure if they are
# In the case of the base64 string above, each of the 22 characters has 64 possibilities, so the probability of two remember tokens colliding is a negligibly small
# By using base64 strings specifically designed to be safe in URLs (as indicated by the nameurlsafe_base64), the same token generator can be used to make account activation and password reset links later

# Remembering users involves creating a remember token and saving the digest of the token to the database
# Digest method is already defined for use in the test fixtures 
# As with digest, the new token method doesn't need a user object, hence define a class method

# Adding a method for generating tokens # def User.new_token
# app/models/user.rb
class User < ActiveRecord::Base
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end  
end

# Make a user.remember method that associates a remember token with the user and saves the corresponding remember digest to the database
# Because of the migration (used above), the User model already has a remember_digest attribute, however it doesn't yet have a remember_token attribute
# Make a token available via user.remember_token (for storage in the cookies) withoutstoring it in the database
# With secure passwords (used above), paired a virtual password attribute with a secure password_digest attribute in the database
# In that case, the virtual password attribute was created automatically by has_secure_password, however code for remember_token has to be written
# The way to do this is to use attr_accessor to create an accessible attribute
# Because of the way Ruby handles assignments inside objects, without self the assignment would create a localvariable
# Using self ensures that assignment sets the user's remember_token attribute like before_savecallback uses self.email instead of just email
# Adding a remember method to the User model # attr_accessor :remember_token # def remember
# app/models/user.rb
class User < ActiveRecord::Base
  attr_accessor :remember_token
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
end

# Login with remembering
# Cookies expire 20.years.from_now

# Adding an authenticated? method to the User model # def authenticated?(remember_token)
# app/models/user.rb
class User < ActiveRecord::Base
  attr_accessor :remember_token
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(remember_token) 
    BCrypt::Password.new(remember_digest).is_password?(remember_token) 
  end
end

# Logging in and remembering a user # remember user
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      log_in user
      remember user
      redirect_to user
    else 
      flash.now[:danger] = 'Invalid email/password combination' 
      render 'new' 
    end 
  end

  def destroy
    log_out 
    redirect_to root_url
  end
end

# Remembering the user
# app/helpers/sessions_helper.rb # user.remember
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Remembers a user in a persistent session. 
  def remember(user) 
    user.remember 
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token 
  end
  
  # Returns the current logged-in user (if any).
  def current_user 
    @current_user ||= User.find_by(id: session[:user_id])
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Logs out the current user.
  def log_out 
    session.delete(:user_id) 
    @current_user = nil
  end
end

# In the case of persistent sessions, retrieve the user from the temporary session if session[:user_id] exists, otherwise look for cookies[:user_id] to retrieve (and log in) the user corresponding to the persistent session
# Updating current_user for persistent sessions # if (user_id = session[:user_id])
# app/helpers/sessions_helper.rb
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Remembers a user in a persistent session. 
  def remember(user) 
    user.remember 
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token 
  end
  
  # Returns the user corresponding to the remember token cookie. 
  def current_user 
    if (user_id = session[:user_id]) 
      @current_user ||= User.find_by(id: user_id) 
    elsif (user_id = cookies.signed[:user_id]) 
      user = User.find_by(id: user_id) 
      if user && user.authenticated?(cookies[:remember_token]) 
        log_in user 
        @current_user = user
      end 
    end 
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Logs out the current user.
  def log_out 
    session.delete(:user_id) 
    @current_user = nil
  end
end

# Note
$ bin/rake db:migrate RAILS_ENV=test
# RED
$ bundle exec rake test
UsersLoginTest#test_login_with_valid_information_followed_by_logout
22 runs, 58 assertions, 1 failures, 0 errors, 0 skips

# Forgetting users
# Adding a forget method to the User model # update_attribute(:remember_digest, nil)
# app/models/user.rb
class User < ActiveRecord::Base
  attr_accessor :remember_token
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(remember_token) 
    BCrypt::Password.new(remember_digest).is_password?(remember_token) 
  end
  
  # Forgets a user. 
  def forget 
    update_attribute(:remember_digest, nil) 
  end
end

# Logging out from a persistent session
# app/helpers/sessions_helper.rb # def forget(user) # forget(current_user)
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Remembers a user in a persistent session. 
  def remember(user) 
    user.remember 
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token 
  end
  
  # Returns the user corresponding to the remember token cookie. 
  def current_user 
    if (user_id = session[:user_id]) 
      @current_user ||= User.find_by(id: user_id) 
    elsif (user_id = cookies.signed[:user_id]) 
      user = User.find_by(id: user_id) 
      if user && user.authenticated?(cookies[:remember_token]) 
        log_in user 
        @current_user = user
      end 
    end 
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Forgets a persistent session. 
  def forget(user) 
    user.forget
    cookies.delete(:user_id) 
    cookies.delete(:remember_token) 
  end 

  # Logs out the current user.
  def log_out
    forget(current_user)
    session.delete(:user_id) 
    @current_user = nil
  end
end

# Two subtle bugs

# There are two closely related subtleties left to address. 
# The first subtlety is that, even though the "Log out" link appears only when logged-in, a user could potentially have multiple browser windows open to the site. If the user then logged out in one window, clicking the "Log out" link in a second window would result in an error due to the use of current_user in (# Adding a forget method to the # User model app/models/user.rb) We can avoid this by logging out only if the user is logged in. 
# The second subtlety is that a user could be logged in (and remembered) in multiple browsers, such as Chrome and Firefox, which causes a problem if the user logs out in one browser but not the other. For example, suppose that the user logs out in Firefox, thereby setting the remember digest to nil (via user.forget). The application will still work in Firefox; because the log_out method in (# Logging out from a persistent session # app/helpers/sessions_helper.rb) deletes the user's id, both highlighted conditionals are false:

# A test for user logout
# test/integration/users_login_test.rb # delete logout_path
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest

  def setup 
    @user = users(:michael) 
  end

  test "login with invalid information" do 
    get login_path 
    assert_template 'sessions/new' 
    post login_path, session: { email: "", password: "" } 
    assert_template 'sessions/new' 
    assert_not flash.empty? 
    get root_path 
    assert flash.empty? 
  end

  test "login with valid information" do 
    get login_path 
    post login_path, session: { email: @user.email, password: 'password' } 
    assert_redirected_to @user 
    follow_redirect! 
    assert_template 'users/show' 
    assert_select "a[href=?]", login_path, count: 0 
    assert_select "a[href=?]", logout_path 
    assert_select "a[href=?]", user_path(@user)
  end

  test "login with valid information followed by logout" do 
    get login_path 
    post login_path, session: { email: @user.email, password: 'password' } 
    assert is_logged_in? 
    assert_redirected_to @user 
    follow_redirect! 
    assert_template 'users/show' 
    assert_select "a[href=?]", login_path, count: 0 
    assert_select "a[href=?]", logout_path 
    assert_select "a[href=?]", user_path(@user) 
    delete logout_path 
    assert_not is_logged_in? 
    assert_redirected_to root_url
    # Simulate a user clicking logout in a second window. 
    delete logout_path
    follow_redirect!       
    assert_select "a[href=?]", login_path 
    assert_select "a[href=?]", logout_path, count: 0 
    assert_select "a[href=?]", user_path(@user), count: 0 
  end
end

# Note
# The second call to delete logout_path (above) should raise an error due to the missing current_user, leading to a RED test suite:
# RED 
$ bundle exec rake test
22 runs, 57 assertions, 0 failures, 1 errors, 0 skips

# Only logging out if logged in
# app/controllers/sessions_controller.rb # log_out if logged_in?
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      log_in user
	  remember user
      redirect_to user
    else 
      flash.now[:danger] = 'Invalid email/password combination' 
      render 'new' 
    end 
  end

  def destroy
    log_out if logged_in? 
    redirect_to root_url
  end
end

# GREEN
$ bundle exec rake test
22 runs, 60 assertions, 0 failures, 0 errors, 0 skips

# A test of authenticated? with a nonexistent digest
# test/models/user_test.rb
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com", password: "foobar", password_confirmation: "foobar")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end
  
  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example. foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end

  test "email addresses should be unique" do 
    duplicate_user = @user.dup
	duplicate_user.email = @user.email.upcase
    @user.save
    assert_not duplicate_user.valid?
  end
  
  test "password should be present (nonblank)" do 
    @user.password = @user.password_confirmation = " " * 6 
    assert_not @user.valid? 
  end

  test "password should have a minimum length" do
    @user.password = @user.password_confirmation = "a" * 5
    assert_not @user.valid?
  end

  test "authenticated? should return false for a user with nil digest" do
    assert_not @user.authenticated?('')
  end
end

# Note:
# Because BCrypt::Password.new(nil) raises an error, the test suite should now be RED
# RED 
$ bundle exec rake test
23 runs, 60 assertions, 0 failures, 1 errors, 0 skips

# Updating authenticated? to handle a nonexistent digest
# app/models/user.rb
class User < ActiveRecord::Base
  attr_accessor :remember_token
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(remember_token)
    return false if remember_digest.nil?
    BCrypt::Password.new(remember_digest).is_password?(remember_token) 
  end
  
  # Forgets a user. 
  def forget 
    update_attribute(:remember_digest, nil) 
  end
end
# The equivalent code (# Returns true if the given token matches the digest.):
if remember_digest.nil? 
  false 
else 
  BCrypt::Password.new(remember_digest).is_password?(remember_token) 
end

# GREEN 
$ bundle exec rake test
23 runs, 61 assertions, 0 failures, 0 errors, 0 skips

# "Remember me" checkbox
# Adding a "remember me" checkbox to the login form # <%= f.label :remember_me, class: "checkbox inline" do %> 
#app/views/sessions/new.html.erb
<% provide(:title, "Log in") %> 
<h1>Log in</h1> 
<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(:session, url: login_path) do |f| %> 
      <%= f.label :email %> <%= f.email_field :email, class: 'form-control' %> 
      <%= f.label :password %> <%= f.password_field :password, class: 'form-control' %>
      <%= f.label :remember_me, class: "checkbox inline" do %> 
        <%= f.check_box :remember_me %> 
        <span>Remember me on this computer</span> 
      <% end %>
      <%= f.submit "Log in", class: "btn btn-primary" %> 
    <% end %>
    <p>New user? <%= link_to "Sign up now!", signup_path %></p> 
  </div> 
</div>

# CSS for the "remember me" checkbox
. 
. 
. 
/* forms */ 
. 
. 
. 
.checkbox { 
  margin-top: -10px; 
  margin-bottom: 10px; 
  span { 
    margin-left: 20px; 
    font-weight: normal; 
  } 
}

#session_remember_me { 
  width: auto; margin-left: 0; 
}
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* mixins, variables, etc. */ 

$gray-medium-light: #eaeaea;

@mixin box_sizing { 
  -moz-box-sizing: border-box; 
  -webkit-box-sizing: border-box; 
  box-sizing: border-box; 
}

/* universal */ 

body { 
  padding-top: 60px; 
} 

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
  h1 { 
    margin-bottom: 10px; 
  } 
} 

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
 line-height: 1;
} 

h1 { 
  font-size: 3em;  
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
} 

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: $gray-light; 
} 

p { 
  font-size: 1.1em; line-height: 1.7em; 
} 

/* header */ 

#logo { 
  float: left; 
  margin-right: 10px; 
  font-size: 1.7em; 
  color: white; 
  text-transform: uppercase; 
  letter-spacing: -1px; 
  padding-top: 9px; 
  font-weight: bold; 
  &:hover { 
    color: white; text-decoration: none; 
  } 
} 

/* footer */ 

footer { 
  margin-top: 45px; 
  padding-top: 5px; 
  border-top: 1px solid $gray-medium-light; 
  color: $gray-light; 
  a { 
    color: $gray; 
    &:hover {
      color: $gray-darker; 
    } 
  } 
  small { 
  float: left; 
  } 
  ul { 
    float: right; 
    list-style: none; 
    li { 
      float: left; 
      margin-left: 15px; 
    } 
  } 
}

/* miscellaneous */

.debug_dump { 
  clear: both; 
  float: left; 
  width: 100%; 
  margin-top: 45px; 
  @include box_sizing; 
}

/* sidebar */ 
aside { 
  section.user_info { 
    margin-top: 20px; 
  } 
  section { 
    padding: 10px 0; 
    margin-top: 20px; 
    &:first-child { 
      border: 0; 
      padding-top: 0; 
    } 
    span { 
      display: block; 
      margin-bottom: 3px; 
      line-height: 1; 
    } 
    h1 { 
      font-size: 1.4em; 
      text-align: left; 
      letter-spacing: -1px; 
      margin-bottom: 3px; 
      margin-top: 0px; 
    } 
  } 
} 

.gravatar { 
  float: left; 
  margin-right: 10px; 
} 
  
.gravatar_edit { 
  margin-top: 15px; 
}

/* forms */

input, textarea, select, .uneditable-input { 
  border: 1px solid #bbb; 
  width: 100%; 
  margin-bottom: 15px; 
  @include box_sizing; 
} 

input { 
  height: auto !important; 
}

#error_explanation { 
  color: red; ul { 
  color: red;
  margin: 0 0 30px 0; 
  } 
} 

.field_with_errors { 
  @extend .has-error; 
  .form-control { 
    color: $state-danger-text;
   } 
}

.checkbox { 
  margin-top: -10px; 
  margin-bottom: 10px; 
  span { 
    margin-left: 20px; 
    font-weight: normal; 
  } 
}

#session_remember_me { 
  width: auto; margin-left: 0; 
}

http://localhost:3000/login

# Handling the submission of the "remember me" checkbox
# app/controllers/sessions_controller.rb # params[:session][:remember_me] == '1' ? remember(user) : forget(user)
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      log_in user
      # remember user
      params[:session][:remember_me] == '1' ? remember(user) : forget(user)
      redirect_to user
    else 
      flash.now[:danger] = 'Invalid email/password combination' 
      render 'new' 
    end 
  end

  def destroy
    log_out if logged_in? 
    redirect_to root_url
  end
end

# Remember tests
# Adding a log_in_as helper
# test/test_helper.rb # Logs in a test user. # private # Returns true inside an integration test.
ENV['RAILS_ENV'] ||= 'test'
require File.expand_path('../../config/environment', __FILE__)
require 'rails/test_help'

class ActiveSupport::TestCase
  # Setup all fixtures in test/fixtures/*.yml for all tests in alphabetical order.
  fixtures :all

  # Returns true if a test user is logged in. 
  def is_logged_in? 
    !session[:user_id].nil? 
  end

  # Logs in a test user. 
  def log_in_as(user, options = {}) 
    password = options[:password] || 'password' 
    remember_me = options[:remember_me] || '1' 
    if integration_test?
	  post login_path, session: { email: user.email, password: password, remember_me: remember_me } 
    else 
      session[:user_id] = user.id 
    end 
  end

  private
    # Returns true inside an integration test. 
    def integration_test? 
      defined?(post_via_redirect) 
    end
end

# A test of the "remember me" checkbox
# test/integration/users_login_test.rb
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest

  def setup 
    @user = users(:michael) 
  end

  test "login with invalid information" do 
    get login_path 
    assert_template 'sessions/new' 
    post login_path, session: { email: "", password: "" } 
    assert_template 'sessions/new' 
    assert_not flash.empty? 
    get root_path 
    assert flash.empty? 
  end

  test "login with valid information" do 
    get login_path 
    post login_path, session: { email: @user.email, password: 'password' } 
    assert_redirected_to @user 
    follow_redirect! 
    assert_template 'users/show' 
    assert_select "a[href=?]", login_path, count: 0 
    assert_select "a[href=?]", logout_path 
    assert_select "a[href=?]", user_path(@user)
  end

  test "login with valid information followed by logout" do 
    get login_path 
    post login_path, session: { email: @user.email, password: 'password' } 
    assert is_logged_in? 
    assert_redirected_to @user 
    follow_redirect! 
    assert_template 'users/show' 
    assert_select "a[href=?]", login_path, count: 0 
    assert_select "a[href=?]", logout_path 
    assert_select "a[href=?]", user_path(@user) 
    delete logout_path 
    assert_not is_logged_in? 
    assert_redirected_to root_url
    # Simulate a user clicking logout in a second window. 
    delete logout_path
    follow_redirect!       
    assert_select "a[href=?]", login_path 
    assert_select "a[href=?]", logout_path, count: 0 
    assert_select "a[href=?]", user_path(@user), count: 0 
  end

  test "login with remembering" do 
    log_in_as(@user, remember_me: '1') 
    assert_not_nil cookies['remember_token'] 
  end 

  test "login without remembering" do 
    log_in_as(@user, remember_me: '0') 
    assert_nil cookies['remember_token'] 
  end
end

# GREEN 
$ bundle exec rake test
25 runs, 63 assertions, 0 failures, 0 errors, 0 skips

# Testing the remember branch
# Raising an exception in an untested branch
# app/helpers/sessions_helper.rb # raise # The tests still pass, so this branch is currently untested.
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Remembers a user in a persistent session. 
  def remember(user) 
    user.remember 
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token 
  end
  
  # Returns the user corresponding to the remember token cookie. 
  def current_user 
    if (user_id = session[:user_id]) 
      @current_user ||= User.find_by(id: user_id) 
    elsif (user_id = cookies.signed[:user_id]) 
      raise # The tests still pass, so this branch is currently untested.
      user = User.find_by(id: user_id) 
      if user && user.authenticated?(cookies[:remember_token]) 
        log_in user 
        @current_user = user
      end 
    end 
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Forgets a persistent session. 
  def forget(user)
    user.forget
    cookies.delete(:user_id) 
    cookies.delete(:remember_token) 
  end 

  # Logs out the current user.
  def log_out
	forget(current_user)
    session.delete(:user_id) 
    @current_user = nil
  end
end

# GREEN 
$ bundle exec rake test
25 runs, 63 assertions, 0 failures, 0 errors, 0 skips

# Code in (# Raising an exception in an untested branch # app/helpers/sessions_helper.rb) is broken
# Persistent sessions are cumbersome to check by hand, so if we ever want to refactor the current_usermethod it's important to test it
# Because the log_in_as helper method defined in (# Adding a log_in_as helper # test/test_helper.rb) automatically setssession[:user_id], testing the "remember" branch of the current_user method is difficult in an integration test. 
# Bypass this restriction by testing the current_usermethod directly in a Sessions helper test, whose file has to be created:
$ touch test/helpers/sessions_helper_test.rb
require 'test_helper' 
class SessionsHelperTest < ActionView::TestCase 
  def setup 
    @user = users(:michael) 
    remember(@user) 
  end 

  test "current_user returns right user when session is nil" do 
    assert_equal @user, current_user 
    assert is_logged_in? 
  end 
  
  test "current_user returns nil when remember digest is wrong" do 
    @user.update_attribute(:remember_digest, User.digest(User.new_token)) 
    assert_nil current_user 
  end 
end

# RED 
$ bundle exec rake test TEST=test/helpers/sessions_helper_test.rb # # raise # The tests still pass, so this branch is currently untested.
2 runs, 0 assertions, 0 failures, 2 errors, 0 skips

# The tests in (# A test for persistent sessions # test/helpers/sessions_helper_test.rb) to pass by removing the raise and restoring the originalcurrent_user method, as in (# Removing the raised exception # app/helpers/sessions_helper.rb)
# (Also verify by removing theauthenticated? expression in (# Removing the raised exception # app/helpers/sessions_helper.rb) that the second test in (# A test for persistent sessions # test/helpers/sessions_helper_test.rb) fails, which confirms that it tests the right thing.)


module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Remembers a user in a persistent session. 
  def remember(user) 
    user.remember 
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token 
  end
  
  # Returns the user corresponding to the remember token cookie. 
  def current_user 
    if (user_id = session[:user_id]) 
      @current_user ||= User.find_by(id: user_id) 
    elsif (user_id = cookies.signed[:user_id]) 
      # raise # The tests still pass, so this branch is currently untested.
      user = User.find_by(id: user_id) 
      if user && user.authenticated?(cookies[:remember_token]) 
        log_in user 
        @current_user = user
      end 
    end 
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Forgets a persistent session. 
  def forget(user)
    user.forget
    cookies.delete(:user_id) 
    cookies.delete(:remember_token) 
  end 

  # Logs out the current user.
  def log_out
	forget(current_user)
    session.delete(:user_id) 
    @current_user = nil
  end
end

# GREEN 
$ bundle exec rake test
27 runs, 66 assertions, 0 failures, 0 errors, 0 skips


## 9 Updating, showing, and deleting users
# REST actions for the Users resource by adding edit, update, index, and destroy actions
# Updating users
# An edit action rendering a view to edit users
# An update action responding to a PATCH request
# Only the current user should be able to update

# Edit form
# The user edit action
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
	# debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
    @user = User.find(params[:id]) 
  end

  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end
end

# The user edit view
$ touch app/views/users/edit.html.erb
# app/views/users/edit.html.erb
<% provide(:title, "Edit user") %> 
<h1>Update your profile</h1> 

<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(@user) do |f| %> 
      <%= render 'shared/error_messages' %> 

      <%= f.label :name %>
      <%= f.text_field :name, class: 'form-control' %> 

      <%= f.label :email %>       
      <%= f.email_field :email, class: 'form-control' %>
 
      <%= f.label :password %> 
      <%= f.password_field :password, class: 'form-control' %> 

      <%= f.label :password_confirmation, "Confirmation" %> 
      <%= f.password_field :password_confirmation, class: 'form-control' %> 

      <%= f.submit "Save changes", class: "btn btn-primary" %> 
    <% end %>

    <div class="gravatar_edit"> 
      <%= gravatar_for @user %> 
      <a href="http://gravatar.com/emails" target="_blank">change</a> 
    </div> 
  </div> 
</div>

$ rails console
User.new.new_record?
Loading development environment (Rails 4.2.5.1)
Switch to inspect mode.
User.new.new_record?
true
User.first.new_record?
User.first.new_record?
  User Load (0.0ms)  SELECT  "users".* FROM "users"  ORDER BY "users"."id" ASC LIMIT 1
false
exit
exit

# Adding a URL to the "Settings" link in the site layout
# app/views/layouts/_header.html.erb # <li><%= link_to "Settings", edit_user_path(current_user) %></li>
<header class="navbar navbar-fixed-top navbar-inverse"> 
  <div class="container"> 
    <%= link_to "sample app", root_path, id: "logo" %>
    <nav> 
      <ul class="nav navbar-nav navbar-right"> 
        <li><%= link_to "Home", root_path %></li> 
        <li><%= link_to "Help", help_path %></li> 
        <% if logged_in? %> 
          <li><%= link_to "Users", '#' %></li> 
          <li class="dropdown"> 
            <a href="#" class="dropdown-toggle" data-toggle="dropdown"> Account <b class="caret"></b> </a> 
            <ul class="dropdown-menu">               
              <li><%= link_to "Profile", current_user %></li> 
              <li><%= link_to "Settings", edit_user_path(current_user) %></li>
              <li class="divider"></li> 
              <li> <%= link_to "Log out", logout_path, method: "delete" %> </li> 
            </ul> 
          </li> 
        <% else %> 
          <li><%= link_to "Log in", login_path %></li> 
        <% end %>  
      </ul> 
    </nav> 
  </div> 
</header>

# Unsuccessful edits
# The initial user update action
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
	# debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
    @user = User.find(params[:id]) 
  end

  def update
    @user = User.find(params[:id]) 
    if @user.update_attributes(user_params) 
      # Handle a successful update. 
    else 
      render 'edit' 
    end
  end

  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end
end

http://localhost:3000/users/1/edit

# Testing unsuccessful edits
$ rails generate integration_test users_edit

# A test for an unsuccessful edit
# test/integration/users_edit_test.rb
require 'test_helper'

class UsersEditTest < ActionDispatch::IntegrationTest
 
  def setup 
    @user = users(:michael) 
  end 

  test "unsuccessful edit" do 
    get edit_user_path(@user) 
    assert_template 'users/edit' 
    patch user_path(@user), user: { name: "", email: "foo@invalid", password: "foo", password_confirmation: "bar" } 
    assert_template 'users/edit' 
  end
end

# GREEN 
$ bundle exec rake test
28 runs, 68 assertions, 0 failures, 0 errors, 0 skips

# Successful edits (with TDD)
# A test of a successful edit
# test/integration/users_edit_test.rb # test "successful edit" do 
require 'test_helper'

class UsersEditTest < ActionDispatch::IntegrationTest
 
  def setup 
    @user = users(:michael) 
  end 

  test "unsuccessful edit" do 
    get edit_user_path(@user) 
    assert_template 'users/edit' 
    patch user_path(@user), user: { name: "", email: "foo@invalid", password: "foo", password_confirmation: "bar" } 
    assert_template 'users/edit' 
  end

  test "successful edit" do 
    get edit_user_path(@user) 
    assert_template 'users/edit' 
    name = "Foo Bar" 
    email = "foo@bar.com"
    patch user_path(@user), user: { name: name, email: email, password: "", password_confirmation: "" }
    assert_not flash.empty? 
    assert_redirected_to @user 
    @user.reload 
    assert_equal name, @user.name 
    assert_equal email, @user.email
  end
end

# The user update action
# app/controllers/users_controller.rb # flash[:success] = "Profile updated" # redirect_to @user
class UsersController < ApplicationController
  def show 
    @user = User.find(params[:id])
	# debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
    @user = User.find(params[:id]) 
  end

  def update
    @user = User.find(params[:id]) 
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end
end

# Allowing empty passwords on update
# app/models/user.rb # validates :password, presence: true, length: { minimum: 6 }, allow_nil: true
class User < ActiveRecord::Base
  attr_accessor :remember_token
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }, allow_nil: true

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(remember_token)
    return false if remember_digest.nil?
    BCrypt::Password.new(remember_digest).is_password?(remember_token) 
  end
  
  # Forgets a user. 
  def forget 
    update_attribute(:remember_digest, nil) 
  end
end

# GREEN 
$ bundle exec rake test
29 runs, 74 assertions, 0 failures, 0 errors, 0 skips

http://localhost:3000/login
Email
example@railstutorial.org
Password
RubyonRails # NOTE: foobar
<Login>
Account -> Settings
http://localhost:3000/users/1/edit
Name
Michael Hartl
Email
example@railstutorial.org
<Save changes>

# Authorization
# In the context of web applications, authentication allows to identify users of our site, andauthorization lets users to control what they can do
# One nice effect of building the authentication machinery (as above) is that now it is possible to implement authorization as well

# Requiring logged-in users
# Adding a logged_in_user before filter
# app/controllers/users_controller.rb # before_action :logged_in_user, only: [:edit, :update] # unless logged_in?
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:edit, :update]
  def show 
    @user = User.find(params[:id])
	# debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
    @user = User.find(params[:id]) 
  end

  def update
    @user = User.find(params[:id]) 
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end
end

http://localhost:3000/users/1/edit
Account -> Log out
http://localhost:3000/users/1/edit

# RED 
$ bundle exec rake test
29 runs, 68 assertions, 2 failures, 0 errors, 0 skips
# The reason is that the edit and update actions now require a logged-in user, however no user is logged in inside the corresponding tests.

# Logging in a test user
# test/integration/users_edit_test.rb
require 'test_helper'

class UsersEditTest < ActionDispatch::IntegrationTest
 
  def setup 
    @user = users(:michael) 
  end 

  test "unsuccessful edit" do
    log_in_as(@user)
    get edit_user_path(@user) 
    assert_template 'users/edit' 
    patch user_path(@user), user: { name: "", email: "foo@invalid", password: "foo", password_confirmation: "bar" } 
    assert_template 'users/edit' 
  end

  test "successful edit" do
    log_in_as(@user)
    get edit_user_path(@user) 
    assert_template 'users/edit' 
    name = "Foo Bar" 
    email = "foo@bar.com"
    patch user_path(@user), user: { name: name, email: email, password: "", password_confirmation: "" }
    assert_not flash.empty? 
    assert_redirected_to @user 
    @user.reload 
    assert_equal name, @user.name 
    assert_equal email, @user.email
  end
end

# GREEN 
$ bundle exec rake test
29 runs, 74 assertions, 0 failures, 0 errors, 0 skips

# Commenting out the before filter to test our security model
# app/controllers/users_controller.rb # # before_action :logged_in_user, only: [:edit, :update]
class UsersController < ApplicationController
  # before_action :logged_in_user, only: [:edit, :update]

  def show 
    @user = User.find(params[:id])
	# debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
    @user = User.find(params[:id]) 
  end

  def update
    @user = User.find(params[:id]) 
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end
end
# Even though the test suite is passing, the before filter is not yet finished, because the suite is still GREEN even if the security model is removed by commenting it out
# GREEN 
$ bundle exec rake test
29 runs, 74 assertions, 0 failures, 0 errors, 0 skips

# Testing that edit and update are protected
# test/controllers/users_controller_test.rb # def setup
require 'test_helper'

class UsersControllerTest < ActionController::TestCase

  def setup 
    @user = users(:michael) 
  end

  test "should get new" do
    get :new
    assert_response :success
  end

  test "should redirect edit when not logged in" do 
    get :edit, id: @user 
    assert_not flash.empty? 
    assert_redirected_to login_url 
  end 

  test "should redirect update when not logged in" do 
    patch :update, id: @user, user: { name: @user.name, email: @user.email } 
    assert_not flash.empty?     
    assert_redirected_to login_url 
  end
end

# The test suite should now be RED
# RED
$ bundle exec rake test
31 runs, 77 assertions, 2 failures, 0 errors, 0 skips

# Uncommenting the before filter
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:edit, :update]

  def show 
    @user = User.find(params[:id])
	# debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
    @user = User.find(params[:id]) 
  end

  def update
    @user = User.find(params[:id]) 
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end
end

# GREEN 
$ bundle exec rake test
31 runs, 78 assertions, 0 failures, 0 errors, 0 skips

# Requiring the right user
# Adding a second user to the fixture file
archer:
  name: Sterling Archer 
  email: duchess@example.gov 
  password_digest: <%= User.digest('password') %>
# test/fixtures/users.yml
michael: 
  name: Michael Example 
  email: michael@example.com 
  password_digest: <%= User.digest('password') %>
  
archer:
  name: Sterling Archer 
  email: duchess@example.gov 
  password_digest: <%= User.digest('password') %>

# Tests for trying to edit as the wrong user
# test/controllers/users_controller_test.rb
require 'test_helper'

class UsersControllerTest < ActionController::TestCase

  def setup 
    @user = users(:michael) 
    @other_user = users(:archer)
  end

  test "should get new" do
    get :new
    assert_response :success
  end

  test "should redirect edit when not logged in" do 
    get :edit, id: @user 
    assert_not flash.empty? 
    assert_redirected_to login_url 
  end 

  test "should redirect update when not logged in" do 
    patch :update, id: @user, user: { name: @user.name, email: @user.email } 
    assert_not flash.empty?     
	assert_redirected_to login_url 
  end

  test "should redirect edit when logged in as wrong user" do 
    log_in_as(@other_user) 
    get :edit, id: @user 
    assert flash.empty? 
    assert_redirected_to root_url 
  end

  test "should redirect update when logged in as wrong user" do 
    log_in_as(@other_user) 
    patch :update, id: @user, user: { name: @user.name, email: @user.email } 
    assert flash.empty? 
    assert_redirected_to root_url
  end
end

# RED
$ bundle exec rake test
33 runs, 81 assertions, 2 failures, 0 errors, 0 skips

# A correct_user before filter to protect the edit/update pages
# app/controllers/users_controller.rb # before_action :correct_user, only: [:edit, :update] # def edit # def update # @user = User.find(params[:id])
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:edit, :update]
  before_action :correct_user, only: [:edit, :update]

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless @user == current_user 
    end
end

# GREEN 
$ bundle exec rake test
33 runs, 82 assertions, 0 failures, 0 errors, 0 skips

# The current_user? method
# app/helpers/sessions_helper.rb # def current_user?(user)
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Remembers a user in a persistent session. 
  def remember(user) 
    user.remember 
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token 
  end
  
  # Returns true if the given user is the current user. 
  def current_user?(user) 
    user == current_user 
  end

  # Returns the user corresponding to the remember token cookie. 
  def current_user 
    if (user_id = session[:user_id]) 
      @current_user ||= User.find_by(id: user_id) 
    elsif (user_id = cookies.signed[:user_id]) 
      # raise # The tests still pass, so this branch is currently untested.
      user = User.find_by(id: user_id) 
      if user && user.authenticated?(cookies[:remember_token]) 
        log_in user 
        @current_user = user
      end 
    end 
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Forgets a persistent session. 
  def forget(user)
    user.forget
    cookies.delete(:user_id) 
    cookies.delete(:remember_token) 
  end 

  # Logs out the current user.
  def log_out
	forget(current_user)
    session.delete(:user_id) 
    @current_user = nil
  end
end

# The final correct_user before filter
# app/controllers/users_controller.rb # redirect_to(root_url) unless current_user?(@user)
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:edit, :update]
  before_action :correct_user, only: [:edit, :update]

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
end

# GREEN 
$ bundle exec rake test
33 runs, 82 assertions, 0 failures, 0 errors, 0 skips

# A test for friendly forwarding
# test/integration/users_edit_test.rb
require 'test_helper'

class UsersEditTest < ActionDispatch::IntegrationTest
 
  def setup 
    @user = users(:michael) 
  end 

  test "unsuccessful edit" do
    log_in_as(@user)
    get edit_user_path(@user) 
    assert_template 'users/edit' 
    patch user_path(@user), user: { name: "", email: "foo@invalid", password: "foo", password_confirmation: "bar" } 
    assert_template 'users/edit' 
  end

  test "successful edit" do
    log_in_as(@user)
    get edit_user_path(@user) 
    assert_template 'users/edit' 
    name = "Foo Bar" 
    email = "foo@bar.com"
    patch user_path(@user), user: { name: name, email: email, password: "", password_confirmation: "" }
    assert_not flash.empty? 
    assert_redirected_to @user 
    @user.reload 
    assert_equal name, @user.name 
    assert_equal email, @user.email
  end

  test "successful edit with friendly forwarding" do
    get edit_user_path(@user) 
    log_in_as(@user) 
    assert_redirected_to edit_user_path(@user) 
    name = "Foo Bar" 
    email = "foo@bar.com"
    patch user_path(@user), user: { name: name, email: email, password: "", password_confirmation: "" }
    assert_not flash.empty? 
    assert_redirected_to @user 
    @user.reload 
    assert_equal name, @user.name 
    assert_equal email, @user.email
  end
end

# Code to implement friendly forwarding
# app/helpers/sessions_helper.rb # def redirect_back_or(default) # def store_location

module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Remembers a user in a persistent session. 
  def remember(user) 
    user.remember 
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token 
  end

  # Returns true if the given user is the current user. 
  def current_user?(user) 
    user == current_user 
  end
  
  # Returns the user corresponding to the remember token cookie. 
  def current_user 
    if (user_id = session[:user_id]) 
      @current_user ||= User.find_by(id: user_id) 
    elsif (user_id = cookies.signed[:user_id]) 
      # raise # The tests still pass, so this branch is currently untested.
      user = User.find_by(id: user_id) 
      if user && user.authenticated?(cookies[:remember_token]) 
        log_in user 
        @current_user = user
      end 
    end 
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Forgets a persistent session. 
  def forget(user)
    user.forget
    cookies.delete(:user_id) 
    cookies.delete(:remember_token) 
  end 

  # Logs out the current user.
  def log_out
	forget(current_user)
    session.delete(:user_id) 
    @current_user = nil
  end

  # Redirects to stored location (or to the default). 
  def redirect_back_or(default) 
    redirect_to(session[:forwarding_url] || default) 
    session.delete(:forwarding_url) 
  end 

  # Stores the URL trying to be accessed. 
  def store_location 
    session[:forwarding_url] = request.url if request.get? 
  end
end

# Adding store_location to the logged-in user before filter
# app/controllers/users_controller.rb # store_location
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:edit, :update]
  before_action :correct_user, only: [:edit, :update]

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in?
        store_location
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
end

# The Sessions create action with friendly forwarding
# app/controllers/sessions_controller.rb # redirect_back_or user
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      log_in user
	  # remember user
      params[:session][:remember_me] == '1' ? remember(user) : forget(user)
      redirect_back_or user
    else 
      flash.now[:danger] = 'Invalid email/password combination' 
      render 'new' 
    end 
  end

  def destroy
    log_out if logged_in? 
    redirect_to root_url
  end
end

# GREEN 
$ bundle exec rake test
34 runs, 89 assertions, 0 failures, 0 errors, 0 skips

# Showing all users
# Users index
# Testing the index action redirect
# test/controllers/users_controller_test.rb # test "should redirect index when not logged in" do 
require 'test_helper'

class UsersControllerTest < ActionController::TestCase

  def setup 
    @user = users(:michael) 
    @other_user = users(:archer)
  end

  test "should redirect index when not logged in" do 
    get :index 
    assert_redirected_to login_url 
  end

  test "should get new" do
    get :new
    assert_response :success
  end

  test "should redirect edit when not logged in" do 
    get :edit, id: @user 
    assert_not flash.empty? 
    assert_redirected_to login_url 
  end 

  test "should redirect update when not logged in" do 
    patch :update, id: @user, user: { name: @user.name, email: @user.email } 
    assert_not flash.empty?     
	assert_redirected_to login_url 
  end

  test "should redirect edit when logged in as wrong user" do 
    log_in_as(@other_user) 
    get :edit, id: @user 
    assert flash.empty? 
    assert_redirected_to root_url 
  end

  test "should redirect update when logged in as wrong user" do 
    log_in_as(@other_user) 
    patch :update, id: @user, user: { name: @user.name, email: @user.email } 
    assert flash.empty? 
    assert_redirected_to root_url
  end
end

# Requiring a logged-in user for the index action
# app/controllers/users_controller.rb # before_action :logged_in_user, only: [:index, :edit, :update] # def index 
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:index, :edit, :update]
  before_action :correct_user, only: [:edit, :update]
  
  def index 
  end

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
	    store_location
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
end

# The user index action
# app/controllers/users_controller.rb # @users = User.all
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:index, :edit, :update]
  before_action :correct_user, only: [:edit, :update]
  
  def index
    @users = User.all
  end

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
	    store_location
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
end

# The users index view
$ touch app/views/users/index.html.erb
# Note # <%= gravatar_for user %> in app/views/users/index.html.erb
[
# app/helpers/users_helper.rb
module UsersHelper
  # Returns the Gravatar for the given user. 
  def gravatar_for(user)
    gravatar_id = Digest::MD5::hexdigest(user.email.downcase) 
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}"   
    image_tag(gravatar_url, alt: user.name, class: "gravatar") 
  end
end

# app/views/users/index.html.erb
<% provide(:title, 'All users') %> 
<h1>All users</h1> 

<ul class="users"> 
  <% @users.each do |user| %> 
    <li> 
      <%= gravatar_for user %> 
      <%= link_to user.name, user %> 
    </li> 
  <% end %> 
</ul>
]

# Note # <%= gravatar_for user, size: 50 %> in app/views/users/index.html.erb
# app/views/users/index.html.erb
<% provide(:title, 'All users') %> 
<h1>All users</h1> 

<ul class="users"> 
  <% @users.each do |user| %> 
    <li> 
      <%= gravatar_for user, size: 50 %> 
      <%= link_to user.name, user %> 
    </li> 
  <% end %> 
</ul>

# Adding an options hash in the gravatar_for helper
# app/helpers/users_helper.rb # size
# https://www.railstutorial.org/book/updating_and_deleting_users#code-user_index_view
module UsersHelper

  # Returns the Gravatar for the given user.
  def gravatar_for(user, options = { size: 80 })
    gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
    size = options[:size]
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}"
    image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end
end

# CSS for the users index
. 
. 
. 
/* Users index */ 

.users { 
  list-style: none; 
  margin: 0; 
  li { 
    overflow: auto;
    padding: 10px 0; 
    border-bottom: 1px solid $gray-lighter; 
  } 
}
# app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets"; 
@import "bootstrap"; 

/* mixins, variables, etc. */ 

$gray-medium-light: #eaeaea;

@mixin box_sizing { 
  -moz-box-sizing: border-box; 
  -webkit-box-sizing: border-box; 
  box-sizing: border-box; 
}

/* universal */ 

body { 
  padding-top: 60px; 
} 

section { 
  overflow: auto; 
} 

textarea { 
  resize: vertical; 
} 

.center { 
  text-align: center; 
  h1 { 
    margin-bottom: 10px; 
  } 
} 

/* typography */ 

h1, h2, h3, h4, h5, h6 { 
 line-height: 1;
} 

h1 { 
  font-size: 3em;  
  letter-spacing: -2px; 
  margin-bottom: 30px; 
  text-align: center; 
} 

h2 { 
  font-size: 1.2em; 
  letter-spacing: -1px; 
  margin-bottom: 30px; 
  text-align: center; 
  font-weight: normal; 
  color: $gray-light; 
} 

p { 
  font-size: 1.1em; line-height: 1.7em; 
} 

/* header */ 

#logo { 
  float: left; 
  margin-right: 10px; 
  font-size: 1.7em; 
  color: white; 
  text-transform: uppercase; 
  letter-spacing: -1px; 
  padding-top: 9px; 
  font-weight: bold; 
  &:hover { 
    color: white; text-decoration: none; 
  } 
} 

/* footer */ 

footer { 
  margin-top: 45px; 
  padding-top: 5px; 
  border-top: 1px solid $gray-medium-light; 
  color: $gray-light; 
  a { 
    color: $gray; 
    &:hover {
      color: $gray-darker; 
    } 
  } 
  small { 
  float: left; 
  } 
  ul { 
    float: right; 
    list-style: none; 
    li { 
      float: left; 
      margin-left: 15px; 
    } 
  } 
}

/* miscellaneous */

.debug_dump { 
  clear: both; 
  float: left; 
  width: 100%; 
  margin-top: 45px; 
  @include box_sizing; 
}

/* sidebar */ 
aside { 
  section.user_info { 
    margin-top: 20px; 
  } 
  section { 
    padding: 10px 0; 
    margin-top: 20px; 
    &:first-child { 
      border: 0; 
      padding-top: 0; 
    } 
    span { 
      display: block; 
      margin-bottom: 3px; 
      line-height: 1; 
    } 
    h1 { 
      font-size: 1.4em; 
      text-align: left; 
      letter-spacing: -1px; 
      margin-bottom: 3px; 
      margin-top: 0px; 
    } 
  } 
} 

.gravatar { 
  float: left; 
  margin-right: 10px; 
} 
  
.gravatar_edit { 
  margin-top: 15px; 
}

/* forms */

input, textarea, select, .uneditable-input { 
  border: 1px solid #bbb; 
  width: 100%; 
  margin-bottom: 15px; 
  @include box_sizing; 
} 

input { 
  height: auto !important; 
}

#error_explanation { 
  color: red; ul { 
  color: red;
  margin: 0 0 30px 0; 
  } 
} 

.field_with_errors { 
  @extend .has-error; 
  .form-control { 
    color: $state-danger-text;
   } 
}

.checkbox { 
  margin-top: -10px; 
  margin-bottom: 10px; 
  span { 
    margin-left: 20px; 
    font-weight: normal; 
  } 
}

#session_remember_me { 
  width: auto; margin-left: 0; 
}

/* Users index */ 

.users { 
  list-style: none; 
  margin: 0; 
  li { 
    overflow: auto;
    padding: 10px 0; 
    border-bottom: 1px solid $gray-lighter; 
  } 
}

# Adding the URL to the users link
# app/views/layouts/_header.html.erb # <li><%= link_to "Users", users_path %></li>
<header class="navbar navbar-fixed-top navbar-inverse"> 
  <div class="container"> 
    <%= link_to "sample app", root_path, id: "logo" %>
    <nav> 
      <ul class="nav navbar-nav navbar-right"> 
        <li><%= link_to "Home", root_path %></li> 
        <li><%= link_to "Help", help_path %></li> 
        <% if logged_in? %> 
          <li><%= link_to "Users", users_path %></li> 
          <li class="dropdown"> 
            <a href="#" class="dropdown-toggle" data-toggle="dropdown"> Account <b class="caret"></b> </a> 
            <ul class="dropdown-menu">               
              <li><%= link_to "Profile", current_user %></li> 
              <li><%= link_to "Settings", edit_user_path(current_user) %></li>
              <li class="divider"></li> 
              <li> <%= link_to "Log out", logout_path, method: "delete" %> </li> 
            </ul> 
          </li> 
        <% else %> 
          <li><%= link_to "Log in", login_path %></li> 
        <% end %>  
      </ul> 
    </nav> 
  </div> 
</header>

# GREEN 
$ bundle exec rake test
35 runs, 90 assertions, 0 failures, 0 errors, 0 skips

http://localhost:3000/users
Email
example@railstutorial.org
Password
RubyonRails # NOTE: foobar

# Sample users
# Adding the Faker gem to the Gemfile
# gem 'faker', '1.4.2'
# https://rubygems.org/gems/faker
# gem 'faker', '~> 1.6', '>= 1.6.3'
# gem 'faker', '~> 1.6'
# Note [Update]
# gem 'faker', '~> 1.6', '>= 1.6.6'
gem 'faker', '~> 1.6'

# install
$ bundle show # Could not find gem 'faker (~> 1.6) x86-mingw32' in any of the gem sources listed in your Gemfile or available on this machine.
$ gem list
$ bundle install
$ bundle show
$ gem list

# A Rake task for seeding the database with sample users
# db/seeds.rb
User.create!(name: "Example User", email: "example@railstutorial.org", password: "foobar", password_confirmation: "foobar") 
  
99.times do |n| 
  name = Faker::Name.name 
  email = "example-#{n+1}@railstutorial.org" 
  password = "password" 
  User.create!(name: name, email: email, password: password, password_confirmation: password) 
end

# Note
[
$ bundle exec rake db:migrate:reset 
$ bundle exec rake db:seed
]
[
$ bundle exec rake db:seed # ActiveRecord::RecordInvalid: Validation failed: Email has already been taken
# db/seeds.rb 
# Edit
# User.create!(name: "Example User", email: "example@railstutorial.org", password: "foobar", password_confirmation: "foobar")
]
$ bin/rake db:reset
# After running the Rake task, our application has 100 sample users.

http://localhost:3000/users
Email
example@railstutorial.org
Password
foobar

# Pagination
# Simplest and most robust, called will_paginate
# To use it, include both the will_paginate gem andbootstrap-will_paginate, which configures will_paginate to use Bootstrap's pagination styles

# Note
# Temporary Solution for gem 'will_paginate', '3.0.7'
# source 'https://rubygems.org'
source 'http://rubygems.org'
# Including will_paginate in the Gemfile
# gem 'will_paginate', '3.0.7' 
# gem 'bootstrap-will_paginate', '0.0.10'
# https://rubygems.org/gems/will_paginate
# gem 'will_paginate', '~> 3.1', '>= 3.1.3'
gem 'will_paginate', '~> 3.1'
# https://rubygems.org/gems/bootstrap-will_paginate
gem 'bootstrap-will_paginate', '~> 0.0.10'

# install
$ bundle show # Could not find gem 'will_paginate (= 3.0.7) x86-mingw32' in any of the gem sources listed in your Gemfile or available on this machine.
$ bundle install
$ bundle show
$ gem list

# The users index with pagination
# app/views/users/index.html.erb # <%= will_paginate %>
<% provide(:title, 'All users') %> 
<h1>All users</h1> 

<%= will_paginate %>

<ul class="users"> 
  <% @users.each do |user| %> 
    <li> 
      <%= gravatar_for user, size: 50 %> 
      <%= link_to user.name, user %> 
    </li> 
  <% end %> 
</ul>

<%= will_paginate %>

# User.paginate(page: 1)
$ rails console
Loading development environment (Rails 4.2.5.1)
Switch to inspect mode.
User.paginate(page: 1)
User.paginate(page: 1)
  User Load (31.2ms)  SELECT  "users".* FROM "users" LIMIT 30 OFFSET 0
   (0.0ms)  SELECT COUNT(*) FROM "users"
#<ActiveRecord::Relation [#<User id: 1, name: "Example User", email: "example@railstutorial.org", created_at: "2016-10-04 13:10:57", updated_at: "2016-10-04 13:10:57", password_digest: "$2a$10$EXbqTN/wFZ/lMLKBoDRGEOxLhTfUvVsoW4Gz0JXeenA...", remember_digest: nil>, #<User id: 2, name: "Mariane Metz", email: "example-1@railstutorial.org", created_at: "2016-10-04 13:10:58", updated_at: "2016-10-04 13:10:58", password_digest: "$2a$10$bli41pDTEmH8xZ4IZBZj..Ze1TSn8fEARmx/8ZI8mlU...", remember_digest: nil>, #<User id: 3, name: "Jailyn Parker", email: "example-2@railstutorial.org", created_at: "2016-10-04 13:10:58", updated_at: "2016-10-04 13:10:58", password_digest: "$2a$10$RETK7jOl5QgF1r3R5iOCteJoXTMvorn7gCXnmuvSSRY...", remember_digest: nil>, #<User id: 4, name: "Mathilde Champlin", email: "example-3@railstutorial.org", created_at: "2016-10-04 13:10:59", updated_at: "2016-10-04 13:10:59", password_digest: "$2a$10$KOwPBZ1OHnfMePIeAlVRMu4FYdgkvnEp4EK6sonqjnm...", remember_digest: nil>, #<User id: 5, name: "Kristina Wuckert III", email: "example-4@railstutorial.org", created_at: "2016-10-04 13:10:59", updated_at: "2016-10-04 13:10:59", password_digest: "$2a$10$x3Pl0TKo9djN95.EyieZJ.5UFL6iMr3j/V/UTVIREhW...", remember_digest: nil>, #<User id: 6, name: "Koby Zemlak", email: "example-5@railstutorial.org", created_at: "2016-10-04 13:10:59", updated_at: "2016-10-04 13:10:59", password_digest: "$2a$10$19Eq1V7yaHYwDDf8tMEpMeGIn1UC/QVMNtxWsUSmtbF...", remember_digest: nil>, #<User id: 7, name: "Lafayette Schinner PhD", email: "example-6@railstutorial.org", created_at: "2016-10-04 13:11:00", updated_at: "2016-10-04 13:11:00", password_digest: "$2a$10$hXc6jQX71tDUGDjPJRyJQuc7sFFm7B2wQYBEx8Uz2ed...", remember_digest: nil>, #<User id: 8, name: "Alexane Bailey", email: "example-7@railstutorial.org", created_at: "2016-10-04 13:11:00", updated_at: "2016-10-04 13:11:00", password_digest: "$2a$10$0BFjo8Mrmr.CboO1rVkMCeJbk.AvElYHizFdZVmmrZ6...", remember_digest: nil>, #<User id: 9, name: "Keely Braun II", email: "example-8@railstutorial.org", created_at: "2016-10-04 13:11:00", updated_at: "2016-10-04 13:11:00", password_digest: "$2a$10$OmObX4u8IgaY/4GLp.I29O14sF2BAUYptzGxR1iw3Dj...", remember_digest: nil>, #<User id: 10, name: "Rosie Schmeler IV", email: "example-9@railstutorial.org", created_at: "2016-10-04 13:11:00", updated_at: "2016-10-04 13:11:00", password_digest: "$2a$10$4otb2bLcO19mmDmyCfDdN.umwaP.m6xrPDQ8QPHrPAV...", remember_digest: nil>, ...]>
exit
exit

# Note that paginate takes a hash argument with key :page and value equal to the page requested
# User.paginate pulls the users out of the database one chunk at a time (30 by default), based on the :page parameter
# For example, page 1 is users 130, page 2 is users 3160, etc
# If page is nil, paginate simply returns the first page

# Using the paginate method, paginate the users in the sample application by using paginate in place of all in the index action
# Here the page parameter comes from params[:page], which is generated automatically by will_paginate
# Paginating the users in the index action
# app/controllers/users_controller.rb # @users = User.paginate(page: params[:page])
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:index, :edit, :update]
  before_action :correct_user, only: [:edit, :update]
  
  def index
    # @users = User.all
    @users = User.paginate(page: params[:page])
  end

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
	    store_location
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
end

http://localhost:3000/users
Email
example@railstutorial.org
Password
foobar

# Users index test
# Adding 30 extra users to the fixture
lana: 
  name: Lana Kane 
  email: hands@example.gov 
  password_digest: <%= User.digest('password') %>

mallory: 
  name: Mallory Archer 
  email: boss@example.gov 
  password_digest: <%= User.digest('password') %> 

<% 30.times do |n| %> 
user_<%= n %>: 
  name: <%= "User #{n}" %> 
  email: <%= "user-#{n}@example.com" %> 
  password_digest: <%= User.digest('password') %> 
<% end %>
# test/fixtures/users.yml
michael: 
  name: Michael Example 
  email: michael@example.com 
  password_digest: <%= User.digest('password') %>
  
archer:
  name: Sterling Archer 
  email: duchess@example.gov 
  password_digest: <%= User.digest('password') %>
  
lana: 
  name: Lana Kane 
  email: hands@example.gov 
  password_digest: <%= User.digest('password') %>

mallory: 
  name: Mallory Archer 
  email: boss@example.gov 
  password_digest: <%= User.digest('password') %> 

<% 30.times do |n| %> 
user_<%= n %>: 
  name: <%= "User #{n}" %> 
  email: <%= "user-#{n}@example.com" %> 
  password_digest: <%= User.digest('password') %> 
<% end %>

# Test of the users index
$ rails generate integration_test users_index

# A test of the users index, including pagination
# test/integration/users_index_test.rb
require 'test_helper'

class UsersIndexTest < ActionDispatch::IntegrationTest
 
  def setup
    @user = users(:michael)
  end
   
  test "index including pagination" do 
    log_in_as(@user) 
    get users_path
    assert_template 'users/index' 
    assert_select 'div.pagination' 
    User.paginate(page: 1).each do |user| 
      assert_select 'a[href=?]', user_path(user), text: user.name 
    end 
  end
end

# GREEN 
$ bundle exec rake test
36 runs, 122 assertions, 0 failures, 0 errors, 0 skips

# Partial refactoring
# The first refactoring attempt in the index view
# app/views/users/index.html.erb # <%= render user %>
<% provide(:title, 'All users') %> 
<h1>All users</h1> 

<%= will_paginate %>

<ul class="users"> 
  <% @users.each do |user| %> 
    <%= render user %>
  <% end %> 
</ul>

<%= will_paginate %>

# A partial to render a single user
# app/views/users/_user.html.erb
$ touch app/views/users/_user.html.erb
<li> 
  <%= gravatar_for user, size: 50 %> 
  <%= link_to user.name, user %> 
</li>

# The fully refactored users index
# app/views/users/index.html.erb # <%= render @users %>
<% provide(:title, 'All users') %> 
<h1>All users</h1> 

<%= will_paginate %>

<ul class="users"> 
  <% @users.each do |user| %> 
    <%= render @users %>
  <% end %> 
</ul>

<%= will_paginate %>

# GREEN 
$ bundle exec rake test
36 runs, 122 assertions, 0 failures, 0 errors, 0 skips

# Deleting users
# Canonical REST action: destroy
# First, create the class of administrative users, or admins, authorized

# Administrative users
# Identify privileged administrative users with a boolean admin attribute in the User model, which will lead automatically to an admin? boolean method to test for admin status

$ rails generate migration add_admin_to_users admin:boolean
# The migration adds the admin column to the users table

# The migration to add a boolean admin attribute to users
# db/migrate/[timestamp]_add_admin_to_users.rb # default: false
class AddAdminToUsers < ActiveRecord::Migration
  def change
    add_column :users, :admin, :boolean, default: false
  end
end

# Migrate
$ bundle exec rake db:migrate

# toggle! method to flip the admin attribute from false to true
$ rails console --sandbox
Loading development environment in sandbox (Rails 4.2.5.1)
Any modifications you make will be rolled back on exit
Switch to inspect mode.
user = User.first
user = User.first
  User Load (1.0ms)  SELECT  "users".* FROM "users"  ORDER BY "users"."id" ASC LIMIT 1
#<User id: 1, name: "Example User", email: "example@railstutorial.org", created_at: "2016-10-04 13:10:57", updated_at: "2016-10-04 13:10:57", password_digest: "$2a$10$EXbqTN/wFZ/lMLKBoDRGEOxLhTfUvVsoW4Gz0JXeenA...", remember_digest: nil, admin: false>
user.admin?
user.admin?
false
user.toggle!(:admin)
user.toggle!(:admin)
   (0.0ms)  SAVEPOINT active_record_1
  SQL (1.0ms)  UPDATE "users" SET "admin" = ?, "updated_at" = ? WHERE "users"."id" = ?  [["admin", "t"], ["updated_at", "2016-10-05 10:27:44.864824"], ["id", 1]]
   (0.0ms)  RELEASE SAVEPOINT active_record_1
true
user.admin?
user.admin?
true
exit
exit
   (1.0ms)  rollback transaction

# The seed data code with an admin user
# db/seeds.rb # admin: true
User.create!(name: "Example User", email: "example@railstutorial.org", password: "foobar", password_confirmation: "foobar", admin: true) 
  
99.times do |n| 
  name = Faker::Name.name 
  email = "example-#{n+1}@railstutorial.org" 
  password = "password" 
  User.create!(name: name, email: email, password: password, password_confirmation: password) 
end

# Reset the database # Note [$ bin/rake db:reset] # Not needed
$ bundle exec rake db:migrate:reset 
$ bundle exec rake db:seed

# Revisiting strong parameters
# The seed data code (db/seeds.rb) with an admin user makes the user an admin by including admin: true in the initialization hash
# This underscores the danger of exposing the objects to the wild Web: if an initialization hash is passed in from an arbitrary web request, a malicious user could send a PATCH request as follows:
patch /users/17?admin=1
# This request would make user 17 an admin, which would be a potentially serious security breach
# Because of this danger, it is essential that we only update attributes that are safe to edit through the web
# This is accomplished using strong parameters by calling require and permit on the params hash (app/controllers/users_controller.rb)
def user_params 
  params.require(:user).permit(:name, :email, :password, :password_confirmation) 
end

# The destroy action
# The final step needed to complete the Users resource is to add delete links and a destroy action
# Add a delete link for each user on the users index page, restricting access to administrative users
# The resulting "delete" links will be displayed only if the current user is an admin
# User delete links (viewable only by admins)
# app/views/users/_user.html.erb # <% if current_user.admin? && !current_user?(user) %> 
<li> 
  <%= gravatar_for user, size: 50 %> 
  <%= link_to user.name, user %>
  <% if current_user.admin? && !current_user?(user) %> 
    | <%= link_to "delete", user, method: :delete, data: { confirm: "You sure?" } %> 
  <% end %>
</li>

http://localhost:3000/users
Email
example@railstutorial.org
Password
foobar

# Adding a working destroy action
# app/controllers/users_controller.rb # before_action :logged_in_user, only: [:index, :edit, :update, :destroy] # def destroy
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:index, :edit, :update, :destroy]
  before_action :correct_user, only: [:edit, :update]
  
  def index
    # @users = User.all
    @users = User.paginate(page: params[:page])
  end

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  def destroy
    User.find(params[:id]).destroy 
    flash[:success] = "User deleted" 
    redirect_to users_url 
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
	    store_location
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
end

# A before filter restricting the destroy action to admins
# app/controllers/users_controller.rb # before_action :admin_user, only: :destroy # def admin_user
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:index, :edit, :update, :destroy]
  before_action :correct_user, only: [:edit, :update]
  before_action :admin_user, only: :destroy
  
  def index
    # @users = User.all
    @users = User.paginate(page: params[:page])
  end

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
	  log_in @user
	  flash[:success] = "Welcome to the Sample App!"
	  redirect_to @user
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  def destroy
    User.find(params[:id]).destroy 
    flash[:success] = "User deleted" 
    redirect_to users_url 
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
	    store_location
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
	
    # Confirms an admin user. 
    def admin_user
      redirect_to(root_url) unless current_user.admin? 
    end
end

# User destroy tests

# Making one of the fixture users an admin
# test/fixtures/users.yml # admin: true
michael: 
  name: Michael Example 
  email: michael@example.com 
  password_digest: <%= User.digest('password') %>
  admin: true
  
archer:
  name: Sterling Archer 
  email: duchess@example.gov 
  password_digest: <%= User.digest('password') %>
  
lana: 
  name: Lana Kane 
  email: hands@example.gov 
  password_digest: <%= User.digest('password') %>

mallory: 
  name: Mallory Archer 
  email: boss@example.gov 
  password_digest: <%= User.digest('password') %> 

<% 30.times do |n| %> 
user_<%= n %>: 
  name: <%= "User #{n}" %> 
  email: <%= "user-#{n}@example.com" %> 
  password_digest: <%= User.digest('password') %> 
<% end %>

# Action-level tests for admin access control
# test/controllers/users_controller_test.rb
require 'test_helper'

class UsersControllerTest < ActionController::TestCase

  def setup 
    @user = users(:michael) 
    @other_user = users(:archer)
  end

  test "should redirect index when not logged in" do 
    get :index 
    assert_redirected_to login_url 
  end
  
  test "should get new" do
    get :new
    assert_response :success
  end

  test "should redirect edit when not logged in" do 
    get :edit, id: @user 
    assert_not flash.empty? 
    assert_redirected_to login_url 
  end 

  test "should redirect update when not logged in" do 
    patch :update, id: @user, user: { name: @user.name, email: @user.email } 
    assert_not flash.empty?     
	assert_redirected_to login_url 
  end

  test "should redirect edit when logged in as wrong user" do 
    log_in_as(@other_user) 
    get :edit, id: @user 
    assert flash.empty? 
    assert_redirected_to root_url 
  end

  test "should redirect update when logged in as wrong user" do 
    log_in_as(@other_user) 
    patch :update, id: @user, user: { name: @user.name, email: @user.email } 
    assert flash.empty? 
    assert_redirected_to root_url
  end

  test "should redirect destroy when not logged in" do 
    assert_no_difference 'User.count' do 
      delete :destroy, id: @user 
    end 
    assert_redirected_to login_url 
  end 
  
  test "should redirect destroy when logged in as a non-admin" do 
    log_in_as(@other_user) 
    assert_no_difference 'User.count' do 
      delete :destroy, id: @user 
    end 
    assert_redirected_to root_url 
  end
end

# An integration test for delete links and destroying users
# test/integration/users_index_test.rb
require 'test_helper'

class UsersIndexTest < ActionDispatch::IntegrationTest
 
  def setup
    @admin = users(:michael) 
    @non_admin = users(:archer)
  end
   
  test "index as admin including pagination and delete links" do 
    log_in_as(@admin) 
    get users_path 
    assert_template 'users/index' 
    assert_select 'div.pagination' 
    first_page_of_users = User.paginate(page: 1) 
    first_page_of_users.each do |user| 
      assert_select 'a[href=?]', user_path(user), text: user.name 
      unless user == @admin 
        assert_select 'a[href=?]', user_path(user), text: 'delete' 
      end 
    end 
    assert_difference 'User.count', -1 do 
      delete user_path(@non_admin) 
    end 
  end

  test "index as non-admin" do 
    log_in_as(@non_admin) 
    get users_path 
    assert_select 'a', text: 'delete', count: 0 
  end
end

# Note
$  bin/rake db:migrate RAILS_ENV=test
# GREEN 
$ bundle exec rake test
39 runs, 157 assertions, 0 failures, 0 errors, 0 skips


## 10 Account activation and password reset
# Account activation
# The analogy between login, remembering, account activation, and password reset
find by		string			digest			authentication
email		password		password_digest		authenticate(password)
id		remember_token		remember_digest		authenticated?(:remember, token)
email		activation_token	activation_digest	authenticated?(:activation, token)
email		reset_token		reset_digest		authenticated?(:reset, token)

# Account Activations controller
$ rails generate controller AccountActivations --no-test-framework

# Adding a resource for account activations
# config/routes.rb # resources :account_activations, only: [:edit]
Rails.application.routes.draw do
  root 'static_pages#home'
  
  # get 'static_pages/help'
  get 'help' => 'static_pages#help'

  # get 'static_pages/about'
  get 'about' => 'static_pages#about'
  
  # get 'static_pages/contact'
  get 'contact' => 'static_pages#contact'
  
  # get 'users/new'
  get 'signup' => 'users#new'
  
  get 'login' => 'sessions#new' 
  post 'login' => 'sessions#create' 
  delete 'logout' => 'sessions#destroy'
  
  resources :users
  resources :account_activations, only: [:edit]
end

# Migration to add the data model, adds all three attributes: activation_digest, activated, activated_at
$ rails generate migration add_activation_to_users activation_digest:string activated:boolean activated_at:datetime

# A migration for account activation (with added index)
# As with the admin attribute (db/migrate/[timestamp]_add_admin_to_users.rb), add a default boolean value of false to the activated attribute 
# db/migrate/[timestamp]_add_activation_to_users.rb # default: false
class AddActivationToUsers < ActiveRecord::Migration
  def change
    add_column :users, :activation_digest, :string
    add_column :users, :activated, :boolean, default: false
    add_column :users, :activated_at, :datetime
  end
end

# Migrate
$ bundle exec rake db:migrate

$ rails console
Loading development environment (Rails 4.2.5.1)
Switch to inspect mode.
User.first.create_activation_digest
User.first.create_activation_digest
  User Load (0.0ms)  SELECT  "users".* FROM "users"  ORDER BY "users"."id" ASC LIMIT 1
NoMethodError: undefined method `create_activation_digest' for #<User:0x462a518>
        from C:/RailsInstaller/Ruby2.2.0/lib/ruby/gems/2.2.0/gems/activemodel-4.2.5.1/lib/active_model/attribute_methods.rb:433:in `method_missing'
        from (irb):1
        from C:/RailsInstaller/Ruby2.2.0/lib/ruby/gems/2.2.0/gems/railties-4.2.5.1/lib/rails/commands/console.rb:110:in `start'
        from C:/RailsInstaller/Ruby2.2.0/lib/ruby/gems/2.2.0/gems/railties-4.2.5.1/lib/rails/commands/console.rb:9:in `start'
        from C:/RailsInstaller/Ruby2.2.0/lib/ruby/gems/2.2.0/gems/railties-4.2.5.1/lib/rails/commands/commands_tasks.rb:68:in `console'
        from C:/RailsInstaller/Ruby2.2.0/lib/ruby/gems/2.2.0/gems/railties-4.2.5.1/lib/rails/commands/commands_tasks.rb:39:in `run_command!'
        from C:/RailsInstaller/Ruby2.2.0/lib/ruby/gems/2.2.0/gems/railties-4.2.5.1/lib/rails/commands.rb:17:in `<top (required)>'
        from bin/rails:4:in `require'
        from bin/rails:4:in `<main>'
exit
exit

# Adding account activation code to the User model
# app/models/user.rb # attr_accessor :remember_token, :activation_token 
# before_save :downcase_email # before_create :create_activation_digest # def downcase_email # def create_activation_digest
class User < ActiveRecord::Base
  attr_accessor :remember_token, :activation_token 
  before_save :downcase_email 
  before_create :create_activation_digest
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }, allow_nil: true

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(remember_token)
    return false if remember_digest.nil?
    BCrypt::Password.new(remember_digest).is_password?(remember_token) 
  end
  
  # Forgets a user. 
  def forget 
    update_attribute(:remember_digest, nil) 
  end

  private
    # Converts email to all lower-case. 
    def downcase_email 
      self.email = email.downcase 
    end

    # Creates and assigns the activation token and digest.
    def create_activation_digest 
      self.activation_token = User.new_token 
      self.activation_digest = User.digest(activation_token) 
    end
end

# Activating seed users by default
# db/seeds.rb # activated: true, activated_at: Time.zone.now
User.create!(name: "Example User", email: "example@railstutorial.org", 
	password: "foobar", password_confirmation: "foobar", 
	admin: true, 
	activated: true, activated_at: Time.zone.now) 
  
99.times do |n| 
  name = Faker::Name.name 
  email = "example-#{n+1}@railstutorial.org" 
  password = "password" 
  User.create!(name: name, email: email, 
	password: password, password_confirmation: password,
	activated: true, activated_at: Time.zone.now) 
end

# Activating fixture users
# test/fixtures/users.yml # activated: true # activated_at: <%= Time.zone.now %>
michael: 
  name: Michael Example 
  email: michael@example.com 
  password_digest: <%= User.digest('password') %>
  admin: true
  activated: true 
  activated_at: <%= Time.zone.now %>
  
archer:
  name: Sterling Archer 
  email: duchess@example.gov 
  password_digest: <%= User.digest('password') %>
  activated: true 
  activated_at: <%= Time.zone.now %>
  
lana: 
  name: Lana Kane 
  email: hands@example.gov 
  password_digest: <%= User.digest('password') %>
  activated: true 
  activated_at: <%= Time.zone.now %>
  
mallory: 
  name: Mallory Archer 
  email: boss@example.gov 
  password_digest: <%= User.digest('password') %> 
  activated: true 
  activated_at: <%= Time.zone.now %>
  
<% 30.times do |n| %> 
user_<%= n %>: 
  name: <%= "User #{n}" %> 
  email: <%= "user-#{n}@example.com" %> 
  password_digest: <%= User.digest('password') %> 
  activated: true 
  activated_at: <%= Time.zone.now %>
<% end %>

$ bundle exec rake db:migrate:reset # Note [$ bin/rake db:reset] # Not needed
$ bundle exec rake db:seed

# Account activation mailer method
# As with models and controllers, we can generate a mailer using rails generate
$ rails generate mailer UserMailer account_activation password_reset

# The generated account activation text view
# app/views/user_mailer/account_activation.text.erb
UserMailer#account_activation

<%= @greeting %>, find me in app/views/user_mailer/account_activation.text.erb

# The generated account activation HTML view
# app/views/user_mailer/account_activation.html.erb
<h1>UserMailer#account_activation</h1>

<p>
  <%= @greeting %>, find me in app/views/user_mailer/account_activation.html.erb
</p>

# The generated application mailer
# app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout 'mailer'
end

# The generated User mailer
# app/mailers/user_mailer.rb
class UserMailer < ApplicationMailer

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.user_mailer.account_activation.subject
  #
  def account_activation
    @greeting = "Hi"

    mail to: "to@example.org"
  end

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.user_mailer.password_reset.subject
  #
  def password_reset
    @greeting = "Hi"

    mail to: "to@example.org"
  end
end

# The application mailer with a new default from address
# app/mailers/application_mailer.rb # "noreply@example.com"
class ApplicationMailer < ActionMailer::Base
  default from: "noreply@example.com"
  layout 'mailer'
end

# Mailing the account activation link
app/mailers/user_mailer.rb # def account_activation(user)
class UserMailer < ApplicationMailer

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.user_mailer.account_activation.subject
  #
  def account_activation(user) 
    @user = user 
    mail to: user.email, 
    subject: "Account activation" 
  end

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.user_mailer.password_reset.subject
  #
  def password_reset
    @greeting = "Hi"

    mail to: "to@example.org"
  end
end

# The account activation text view
# app/views/user_mailer/account_activation.text.erb
Hi <%= @user.name %>, 

Welcome to the Sample App! Click on the link below to activate your account: 

<%= edit_account_activation_url(@user.activation_token, email: @user.email) %>

# The account activation HTML view
# app/views/user_mailer/account_activation.html.erb
<h1>Sample App</h1> 

<p>Hi <%= @user.name %>,</p> 

<p> 
Welcome to the Sample App! Click on the link below to activate your account: 
</p> 

<%= link_to "Activate", edit_account_activation_url(@user.activation_token, email: @user.email) %>

# Email settings in development
config.action_mailer.raise_delivery_errors = true
config.action_mailer.delivery_method = :test
host = 'localhost:3000' # Local server
config.action_mailer.default_url_options = { host: host }
# config/environments/development.rb
Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # In the development environment your application's code is reloaded on
  # every request. This slows down response time but is perfect for development
  # since you don't have to restart the web server when you make code changes.
  config.cache_classes = false

  # Do not eager load code on boot.
  config.eager_load = false

  # Show full error reports and disable caching.
  config.consider_all_requests_local       = true
  config.action_controller.perform_caching = false
  
  # Don't care if the mailer can't send.
  # config.action_mailer.raise_delivery_errors = false
  config.action_mailer.raise_delivery_errors = true
  config.action_mailer.delivery_method = :test
  host = 'localhost:3000' # Local server
  config.action_mailer.default_url_options = { host: host }

  # Print deprecation notices to the Rails logger.
  config.active_support.deprecation = :log

  # Raise an error on page load if there are pending migrations.
  config.active_record.migration_error = :page_load

  # Debug mode disables concatenation and preprocessing of assets.
  # This option may cause significant delays in view rendering with a large
  # number of complex assets.
  config.assets.debug = true

  # Asset digests allow you to set far-future HTTP expiration dates on all assets,
  # yet still be able to expire them through the digest params.
  config.assets.digest = true

  # Adds additional error checking when serving assets at runtime.
  # Checks for improperly declared sprockets dependencies.
  # Raises helpful error messages.
  config.assets.raise_runtime_errors = true

  # Raises error for missing translations
  # config.action_view.raise_on_missing_translations = true
end

# The generated User mailer previews
# test/mailers/previews/user_mailer_preview.rb
# Preview all emails at http://localhost:3000/rails/mailers/user_mailer
class UserMailerPreview < ActionMailer::Preview

  # Preview this email at http://localhost:3000/rails/mailers/user_mailer/account_activation
  def account_activation
    UserMailer.account_activation
  end

  # Preview this email at http://localhost:3000/rails/mailers/user_mailer/password_reset
  def password_reset
    UserMailer.password_reset
  end

end

# A working preview method for account activation
# test/mailers/previews/user_mailer_preview.rb
class UserMailerPreview < ActionMailer::Preview

  # Preview this email at http://localhost:3000/rails/mailers/user_mailer/account_activation
  def account_activation
    user = User.first 
    user.activation_token = User.new_token 
    UserMailer.account_activation(user)
  end

  # Preview this email at http://localhost:3000/rails/mailers/user_mailer/password_reset
  def password_reset
    UserMailer.password_reset
  end

end

http://localhost:3000/rails/mailers/user_mailer/account_activation

# The User mailer test generated by Rails
# test/mailers/user_mailer_test.rb
require 'test_helper'

class UserMailerTest < ActionMailer::TestCase
  test "account_activation" do
    mail = UserMailer.account_activation
    assert_equal "Account activation", mail.subject
    assert_equal ["to@example.org"], mail.to
    assert_equal ["from@example.com"], mail.from
    assert_match "Hi", mail.body.encoded
  end

  test "password_reset" do
    mail = UserMailer.password_reset
    assert_equal "Password reset", mail.subject
    assert_equal ["to@example.org"], mail.to
    assert_equal ["from@example.com"], mail.from
    assert_match "Hi", mail.body.encoded
  end

end

# A test of the current email implementation
# test/mailers/user_mailer_test.rb # test "account_activation" do
require 'test_helper'

class UserMailerTest < ActionMailer::TestCase
  test "account_activation" do
    user = users(:michael) 
    user.activation_token = User.new_token 
    mail = UserMailer.account_activation(user) 
    assert_equal "Account activation", mail.subject 
    assert_equal [user.email], mail.to 
    assert_equal ["noreply@example.com"], mail.from 
    assert_match user.name, mail.body.encoded 
    assert_match user.activation_token, mail.body.encoded 
    assert_match CGI::escape(user.email), mail.body.encoded
  end
end

# To get the test to pass,configure the test file with the proper domain host
# Setting the test domain host
# config/environments/test.rb # config.action_mailer.default_url_options = { host: 'example.com' }
Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # The test environment is used exclusively to run your application's
  # test suite. You never need to work with it otherwise. Remember that
  # your test database is "scratch space" for the test suite and is wiped
  # and recreated between test runs. Don't rely on the data there!
  config.cache_classes = true

  # Do not eager load code on boot. This avoids loading your whole application
  # just for the purpose of running a single test. If you are using a tool that
  # preloads Rails for running tests, you may have to set it to true.
  config.eager_load = false

  # Configure static file server for tests with Cache-Control for performance.
  config.serve_static_files   = true
  config.static_cache_control = 'public, max-age=3600'

  # Show full error reports and disable caching.
  config.consider_all_requests_local       = true
  config.action_controller.perform_caching = false

  # Raise exceptions instead of rendering exception templates.
  config.action_dispatch.show_exceptions = false

  # Disable request forgery protection in test environment.
  config.action_controller.allow_forgery_protection = false

  # Tell Action Mailer not to deliver emails to the real world.
  # The :test delivery method accumulates sent emails in the
  # ActionMailer::Base.deliveries array.
  config.action_mailer.delivery_method = :test
  config.action_mailer.default_url_options = { host: 'example.com' }
  
  # Randomize the order test cases are executed.
  config.active_support.test_order = :random

  # Print deprecation notices to the stderr.
  config.active_support.deprecation = :stderr

  # Raises error for missing translations
  # config.action_view.raise_on_missing_translations = true
end

# Note
$ bin/rake db:migrate RAILS_ENV=test
# GREEN 
$ bundle exec rake test:mailers
1 runs, 9 assertions, 0 failures, 0 errors, 0 skips

# Adding account activation to user signup
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:index, :edit, :update, :destroy]
  before_action :correct_user, only: [:edit, :update]
  before_action :admin_user, only: :destroy
  
  def index
    # @users = User.all
    @users = User.paginate(page: params[:page])
  end

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
      UserMailer.account_activation(@user).deliver_now 
      flash[:info] = "Please check your email to activate your account." 
      redirect_to root_url
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  def destroy
    User.find(params[:id]).destroy 
    flash[:success] = "User deleted" 
    redirect_to users_url 
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
	    store_location
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
	
    # Confirms an admin user. 
    def admin_user 
      redirect_to(root_url) unless current_user.admin? 
    end
end

# RED 
$ bundle exec rake test
UsersSignupTest#test_valid_signup_information
40 runs, 165 assertions, 1 failures, 0 errors, 0 skips

# Temporarily commenting out failing tests
# test/integration/users_signup_test.rb
require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest
  test "invalid signup information" do
    get signup_path 
    assert_no_difference 'User.count' do 
      post users_path, user: { name: "", email: "user@invalid", password: "foo",   password_confirmation: "bar" } 
    end 
    assert_template 'users/new'
  end
  
  test "valid signup information" do
    get signup_path 
    assert_difference 'User.count', 1 do 
      post_via_redirect users_path, user: { name: "Example User", email: "user@example.com", password: "password", password_confirmation: "password" }
    end 
    # assert_template 'users/show'
    # assert is_logged_in?
  end
end

# GREEN 
$ bundle exec rake test
40 runs, 164 assertions, 0 failures, 0 errors, 0 skips

$ rails console
Loading development environment (Rails 4.2.5.1)
Switch to inspect mode.
user = User.first
user = User.first
  User Load (0.0ms)  SELECT  "users".* FROM "users"  ORDER BY "users"."id" ASC LIMIT 1
#<User id: 1, name: "Example User", email: "example@railstutorial.org", created_at: "2016-10-05 12:41:15", updated_at: "2016-10-05 12:41:15", password_digest: "$2a$10$u861nsMRGpO7xvG.T36wfuKCQhKonTo1uqdGgB2HM/L...", remember_digest: nil, admin: true, activation_digest: "$2a$10$/yBscoM24T7HOKDjl4y.8uu455FInYLTxHLTWEjyhlL...", activated: true, activated_at: "2016-10-05 12:41:15">
user.activation_digest
user.activation_digest
"$2a$10$/yBscoM24T7HOKDjl4y.8uu455FInYLTxHLTWEjyhlLKtjARWeaNC"
user.send(:activation_digest)
user.send(:activation_digest)
"$2a$10$/yBscoM24T7HOKDjl4y.8uu455FInYLTxHLTWEjyhlLKtjARWeaNC"
user.send('activation_digest')
user.send('activation_digest')
"$2a$10$/yBscoM24T7HOKDjl4y.8uu455FInYLTxHLTWEjyhlLKtjARWeaNC"
attribute = :activation
attribute = :activation
:activation
user.send("#{attribute}_digest")
user.send("#{attribute}_digest")
"$2a$10$/yBscoM24T7HOKDjl4y.8uu455FInYLTxHLTWEjyhlLKtjARWeaNC"
exit
exit

$ rails console
e = User.find_by_id(1)
e = User.find_by_email('example@railstutorial.org')
m = User.find_by_id(101)
m = User.find_by_email('michael@michaelhartl.com')
m.send('activation_digest')
exit

# Activating the account
# A generalized authenticated? method
# app/models/user.rb # def authenticated?(attribute, token) 
class User < ActiveRecord::Base
  attr_accessor :remember_token, :activation_token 
  before_save :downcase_email 
  before_create :create_activation_digest
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }, allow_nil: true

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(attribute, token) 
    digest = send("#{attribute}_digest") 
    return false if digest.nil? 
    BCrypt::Password.new(digest).is_password?(token) 
  end
  
  # Forgets a user. 
  def forget 
    update_attribute(:remember_digest, nil) 
  end

  private
    # Converts email to all lower-case. 
    def downcase_email 
      self.email = email.downcase 
    end

    # Creates and assigns the activation token and digest.
    def create_activation_digest 
      self.activation_token = User.new_token 
      self.activation_digest = User.digest(activation_token) 
    end
end

# RED 
$ bundle exec rake test
# The reason for the failure is that the current_user method (# Updating current_user for persistent sessions # app/helpers/sessions_helper.rb) and the test for nil digests (# A test of authenticated? with a nonexistent digest # test/models/user_test.rb) both use the old version of authenticated?, which expects one argument instead of two
# To fix this, update the two cases to use the generalized method
# Using the generalized authenticated? method in current_user
# app/helpers/sessions_helper.rb # if user && user.authenticated?(:remember, cookies[:remember_token])
module SessionsHelper

  # Logs in the given user. 
  def log_in(user) 
    session[:user_id] = user.id 
  end

  # Remembers a user in a persistent session. 
  def remember(user) 
    user.remember 
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token 
  end

  # Returns true if the given user is the current user. 
  def current_user?(user) 
    user == current_user 
  end
  
  # Returns the user corresponding to the remember token cookie. 
  def current_user 
    if (user_id = session[:user_id]) 
      @current_user ||= User.find_by(id: user_id) 
    elsif (user_id = cookies.signed[:user_id]) 
      # raise # The tests still pass, so this branch is currently untested.
      user = User.find_by(id: user_id) 
      if user && user.authenticated?(:remember, cookies[:remember_token])
        log_in user 
        @current_user = user
      end 
    end 
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in? 
    !current_user.nil?
  end

  # Forgets a persistent session. 
  def forget(user)
    user.forget
    cookies.delete(:user_id) 
    cookies.delete(:remember_token) 
  end 

  # Logs out the current user.
  def log_out
	forget(current_user)
    session.delete(:user_id) 
    @current_user = nil
  end
  
  # Redirects to stored location (or to the default). 
  def redirect_back_or(default) 
    redirect_to(session[:forwarding_url] || default) 
    session.delete(:forwarding_url) 
  end 

  # Stores the URL trying to be accessed. 
  def store_location 
    session[:forwarding_url] = request.url if request.get? 
  end
end

# Using the generalized authenticated? method in the User test
# test/models/user_test.rb # assert_not @user.authenticated?(:remember, '')
require 'test_helper' 

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com", password: "foobar", password_confirmation: "foobar")
  end

  test "should be valid" do
    assert @user.valid?
  end
  
  test "name should be present" do 
    @user.name = " " 
    assert_not @user.valid? 
  end

  test "email should be present" do 
    @user.email = " " 
    assert_not @user.valid? 
  end 
  
  test "name should not be too long" do 
    @user.name = "a" * 51 + "@example.com"
    assert_not @user.valid? 
  end

  test "email should not be too long" do 
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid? 
  end
  
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end
  
  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example. foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end

  test "email addresses should be unique" do 
    duplicate_user = @user.dup
	duplicate_user.email = @user.email.upcase
    @user.save
    assert_not duplicate_user.valid?
  end
  
    test "password should be present (nonblank)" do 
    @user.password = @user.password_confirmation = " " * 6 
    assert_not @user.valid? 
  end

  test "password should have a minimum length" do
    @user.password = @user.password_confirmation = "a" * 5
    assert_not @user.valid?
  end

  test "authenticated? should return false for a user with nil digest" do
    assert_not @user.authenticated?(:remember, '')
  end
end

# GREEN 
$ bundle exec rake test
40 runs, 164 assertions, 0 failures, 0 errors, 0 skips

# An edit action to activate accounts
# app/controllers/account_activations_controller.rb
class AccountActivationsController < ApplicationController
  def edit 
    user = User.find_by(email: params[:email]) 
    if user && !user.activated? && user.authenticated?(:activation, params[:id]) 
      user.update_attribute(:activated, true) 
      user.update_attribute(:activated_at, Time.zone.now) 
      log_in user 
      flash[:success] = "Account activated!" 
      redirect_to user 
    else 
      flash[:danger] = "Invalid activation link" 
      redirect_to root_url 
    end 
  end
end

[
http://localhost:3000/account_activations/fFb_F94mgQtmlSvRFGsITw/edit?email=michael%40michaelhartl.com
]

# Currently user activation doesn't actually do anything, because how users log hasn't been changed
# To have account activation mean something, allow users to log in only if they are activated
# Log the user in as usual if user.activated? is true; otherwise, redirect to the root URL with a warning message
# Preventing unactivated users from logging in
# app/controllers/sessions_controller.rb # if user.activated?
class SessionsController < ApplicationController
  def new
  end

  def create 
    user = User.find_by(email: params[:session][:email].downcase) 
    if user && user.authenticate(params[:session][:password]) 
      if user.activated? 
        log_in user 
        params[:session][:remember_me] == '1' ? remember(user) : forget(user) 
        redirect_back_or user 
      else 
        message = "Account not activated. " 
        message += "Check your email for the activation link." 
        flash[:warning] = message 
        redirect_to root_url end
    else 
      flash.now[:danger] = 'Invalid email/password combination' 
      render 'new' 
    end 
  end

  def destroy
    log_out if logged_in? 
    redirect_to root_url
  end
end

http://localhost:3000/signup
Name 
Michael Hartl
Email 
michael@michaelhartl.com
Password
RubyEvangelist
Confirmation
RubyEvangelist

http://localhost:3000/login
Email 
michael@michaelhartl.com
Password
RubyEvangelist

# Activation test and refactoring
# Adding account activation to the user signup test
# test/integration/users_signup_test.rb # def setup # test "valid signup information with account activation" do
require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest

  def setup 
    ActionMailer::Base.deliveries.clear 
  end

  test "invalid signup information" do
    get signup_path 
    assert_no_difference 'User.count' do 
      post users_path, user: { name: "", email: "user@invalid", password: "foo",   password_confirmation: "bar" } 
    end 
    assert_template 'users/new'
  end
  
  test "valid signup information with account activation" do 
    get signup_path 
    assert_difference 'User.count', 1 do 
      post users_path, user: { name: "Example User", email: "user@example.com", password: "password", password_confirmation: "password" } 
    end 
    assert_equal 1, ActionMailer::Base.deliveries.size 
    user = assigns(:user) 
    assert_not user.activated? 
    # Try to log in before activation. 
    log_in_as(user) 
    assert_not is_logged_in? 
    # Invalid activation token 
    get edit_account_activation_path("invalid token") 
    assert_not is_logged_in? 
    # Valid token, wrong email 
    get edit_account_activation_path(user.activation_token, email: 'wrong') 
    assert_not is_logged_in? 
    # Valid activation token 
    get edit_account_activation_path(user.activation_token, email: user.email) 
    assert user.reload.activated? 
    follow_redirect! 
    assert_template 'users/show' 
    assert is_logged_in? 
  end
end

# GREEN 
$ bundle exec rake test
40 runs, 172 assertions, 0 failures, 0 errors, 0 skips

# Adding user activation methods to the User model
# app/models/user.rb # def activate # def send_activation_email # self is optional inside the model
class User < ActiveRecord::Base
  attr_accessor :remember_token, :activation_token 
  before_save :downcase_email 
  before_create :create_activation_digest
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }, allow_nil: true

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(attribute, token) 
    digest = send("#{attribute}_digest") 
    return false if digest.nil? 
    BCrypt::Password.new(digest).is_password?(token) 
  end
  
  # Forgets a user. 
  def forget 
    update_attribute(:remember_digest, nil) 
  end

  # Activates an account. 
  def activate 
    update_attribute(:activated, true) 
    update_attribute(:activated_at, Time.zone.now) 
  end 

  # Sends activation email. 
  def send_activation_email 
    UserMailer.account_activation(self).deliver_now 
  end

  private
    # Converts email to all lower-case. 
    def downcase_email 
      self.email = email.downcase 
    end

    # Creates and assigns the activation token and digest.
    def create_activation_digest 
      self.activation_token = User.new_token 
      self.activation_digest = User.digest(activation_token) 
    end
end

# Sending email via the user model object
# app/controllers/users_controller.rb # @user.send_activation_email
class UsersController < ApplicationController
  before_action :logged_in_user, only: [:index, :edit, :update, :destroy]
  before_action :correct_user, only: [:edit, :update]
  before_action :admin_user, only: :destroy
  
  def index
    # @users = User.all
    @users = User.paginate(page: params[:page])
  end

  def show 
    @user = User.find(params[:id])
    # debugger
  end
  
  def new
    @user = User.new
  end
  
  def create 
    @user = User.new(user_params)
    if @user.save 
      @user.send_activation_email
      flash[:info] = "Please check your email to activate your account." 
      redirect_to root_url
    else 
      render 'new' 
    end 
  end

  def edit 
  end

  def update
    if @user.update_attributes(user_params) 
      flash[:success] = "Profile updated" 
      redirect_to @user 
    else 
      render 'edit' 
    end
  end
  
  def destroy
    User.find(params[:id]).destroy 
    flash[:success] = "User deleted" 
    redirect_to users_url 
  end
  
  private
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    end

    # Before filters 
    # Confirms a logged-in user. 
    def logged_in_user 
      unless logged_in? 
	    store_location
        flash[:danger] = "Please log in." 
        redirect_to login_url 
      end 
    end

    # Confirms the correct user. 
    def correct_user 
      @user = User.find(params[:id]) 
      redirect_to(root_url) unless current_user?(@user) 
    end
	
    # Confirms an admin user. 
    def admin_user 
      redirect_to(root_url) unless current_user.admin? 
    end
end

# Account activation via the user model object
# app/controllers/account_activations_controller.rb # user.activate
class AccountActivationsController < ApplicationController
  def edit 
    user = User.find_by(email: params[:email]) 
    if user && !user.activated? && user.authenticated?(:activation, params[:id]) 
      user.activate 
      log_in user 
	  flash[:success] = "Account activated!" 
      redirect_to user 
    else 
      flash[:danger] = "Invalid activation link" 
      redirect_to root_url 
    end 
  end
end

# GREEN 
$ bundle exec rake test
40 runs, 172 assertions, 0 failures, 0 errors, 0 skips

# Password reset
# Password resets resource
$ rails generate controller PasswordResets new edit --no-test-framework

# Adding a resource for password resets
# config/routes.rb # resources :password_resets, only: [:new, :create, :edit, :update] 
# Remove # get 'password_resets/new' # get 'password_resets/edit'
Rails.application.routes.draw do
  root 'static_pages#home'
  
  # get 'static_pages/help'
  get 'help' => 'static_pages#help'

  # get 'static_pages/about'
  get 'about' => 'static_pages#about'
  
  # get 'static_pages/contact'
  get 'contact' => 'static_pages#contact'
  
  # get 'users/new'
  get 'signup' => 'users#new'
  
  get 'login' => 'sessions#new' 
  post 'login' => 'sessions#create' 
  delete 'logout' => 'sessions#destroy'
  
  resources :users  
  resources :account_activations, only: [:edit]
  resources :password_resets, only: [:new, :create, :edit, :update]
end

# RESTful routes provided by the Password Resets resource
HTTP request	URL				Action		Named route
GET		/password_resets/new		new		new_password_reset_path
POST		/password_resets		create		password_resets_path
GET		/password_resets/<token>/edit	edit		edit_password_reset_path(token)
PATCH		/password_resets/<token>	update		password_reset_path(token)

# Adding a link to password resets
# app/views/sessions/new.html.erb # <%= link_to "(forgot password)", new_password_reset_path %>
<% provide(:title, "Log in") %> 
<h1>Log in</h1> 

<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(:session, url: login_path) do |f| %> 

      <%= f.label :email %> 
      <%= f.email_field :email, class: 'form-control' %> 

      <%= f.label :password %> 
      <%= link_to "(forgot password)", new_password_reset_path %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :remember_me, class: "checkbox inline" do %> 
        <%= f.check_box :remember_me %> 
        <span>Remember me on this computer</span> 
      <% end %>

      <%= f.submit "Log in", class: "btn btn-primary" %> 
    <% end %>

    <p>New user? <%= link_to "Sign up now!", signup_path %></p> 
  </div> 
</div>

http://localhost:3000/login

# The data model for password resets is similar to the one used for account activation
# Following the pattern set by remember tokens (# Remember me) and account activation tokens (# Account activation), password resets will pair a virtual reset token for use in the reset email with a corresponding reset digest for retrieving the user
# Using a digest for password resets is thus essential
# As an additional security precaution, plan to expire the reset link after a couple of hours, which requires recording the time when the reset gets sent
# Migration to add the attributes 
$ rails generate migration add_reset_to_users reset_digest:string reset_sent_at:datetime

# Migrate 
$ bundle exec rake db:migrate

# Password resets controller and form
# Reviewing the code for the login form
# app/views/sessions/new.html.erb
<% provide(:title, "Log in") %> 
<h1>Log in</h1> 

<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(:session, url: login_path) do |f| %> 

      <%= f.label :email %> 
      <%= f.email_field :email, class: 'form-control' %> 

      <%= f.label :password %> 
      <%= link_to "(forgot password)", new_password_reset_path %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :remember_me, class: "checkbox inline" do %> 
        <%= f.check_box :remember_me %> 
        <span>Remember me on this computer</span> 
      <% end %>

      <%= f.submit "Log in", class: "btn btn-primary" %> 
    <% end %>

    <p>New user? <%= link_to "Sign up now!", signup_path %></p> 
  </div> 
</div>

# A new password reset view
# app/views/password_resets/new.html.erb
<% provide(:title, "Forgot password") %> 
<h1>Forgot password</h1> 

<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(:password_reset, url: password_resets_path) do |f| %>

      <%= f.label :email %> 
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.submit "Submit", class: "btn btn-primary" %> 
    <% end %> 
  </div> 
</div>

http://localhost:3000/password_resets/new

# Upon submitting the form, find the user by email address and update its attributes with the password reset token and sent-at timestamp
# Then redirect to the root URL with an informative flash message
# As with login (# Correct code for failed login # app/controllers/sessions_controller.rb), in the case of an invalid submission we re-render the new page with a flash.now message
# A create action for password resets
# app/controllers/password_resets_controller.rb
class PasswordResetsController < ApplicationController
  def new
  end

  def create 
    @user = User.find_by(email: params[:password_reset][:email].downcase) 
    if @user
      @user.create_reset_digest 
      @user.send_password_reset_email 
      flash[:info] = "Email sent with password reset instructions." 
      redirect_to root_url 
    else 
      flash.now[:danger] = "Email address not found." 
      render 'new' 
    end 
  end

  def edit
  end
end

# Adding password reset methods to the User model
# app/models/user.rb # attr_accessor :remember_token, :activation_token, :reset_token # def create_reset_digest # def send_password_reset_email 
class User < ActiveRecord::Base
  attr_accessor :remember_token, :activation_token, :reset_token 
  before_save :downcase_email 
  before_create :create_activation_digest
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }, allow_nil: true

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(attribute, token) 
    digest = send("#{attribute}_digest") 
    return false if digest.nil? 
    BCrypt::Password.new(digest).is_password?(token) 
  end
  
  # Forgets a user. 
  def forget 
    update_attribute(:remember_digest, nil) 
  end

  # Activates an account. 
  def activate 
    update_attribute(:activated, true) 
    update_attribute(:activated_at, Time.zone.now) 
  end 

  # Sends activation email. 
  def send_activation_email 
    UserMailer.account_activation(self).deliver_now 
  end

  # Sets the password reset attributes. 
  def create_reset_digest 
    self.reset_token = User.new_token 
    update_attribute(:reset_digest, User.digest(reset_token)) 
    update_attribute(:reset_sent_at, Time.zone.now) 
  end 

  # Sends password reset email. 
  def send_password_reset_email 
    UserMailer.password_reset(self).deliver_now 
  end

  private
    # Converts email to all lower-case. 
    def downcase_email 
      self.email = email.downcase 
    end

    # Creates and assigns the activation token and digest.
    def create_activation_digest 
      self.activation_token = User.new_token 
      self.activation_digest = User.digest(activation_token) 
    end
end

http://localhost:3000/password_resets/new
unknown@unknown.com
"Email address not found."

# Password reset mailer method
# Mailing the password reset link
# app/mailers/user_mailer.rb # def password_reset(user)
class UserMailer < ApplicationMailer

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.user_mailer.account_activation.subject
  #
  def account_activation(user) 
    @user = user 
    mail to: user.email, subject: "Account activation" 
  end

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.user_mailer.password_reset.subject
  #
  def password_reset(user)
    @user = user 
    mail to: user.email, subject: "Password reset"
  end
end

# The password reset plain-text email template
# app/views/user_mailer/password_reset.text.erb
To reset your password click the link below: 

<%= edit_password_reset_url(@user.reset_token, email: @user.email) %> 

This link will expire in two hours. 

If you did not request your password to be reset, please ignore this email and your password will stay as it is.

# The password reset HTML email template
# app/views/user_mailer/password_reset.html.erb
<h1>Password reset</h1> 

<p>To reset your password click the link below:</p> 

<%= link_to "Reset password", edit_password_reset_url(@user.reset_token, email: @user.email) %> 

<p>This link will expire in two hours.</p>

<p> If you did not request your password to be reset, please ignore this email and your password will stay as it is. </p>

# As with account activation emails (# Account activation mailer method), preview password reset emails using the Rails email previewer
# The code is exactly analogous to (# A working preview method for account activation # test/mailers/prevews/user_mailer_preview.rb)
# A working preview method for password reset
# test/mailers/previews/user_mailer_preview.rb # def password_reset
class UserMailerPreview < ActionMailer::Preview

  # Preview this email at http://localhost:3000/rails/mailers/user_mailer/account_activation
  def account_activation
    user = User.first 
    user.activation_token = User.new_token 
    UserMailer.account_activation(user)
  end

  # Preview this email at http://localhost:3000/rails/mailers/user_mailer/password_reset
  def password_reset
    user = User.first 
    user.reset_token = User.new_token 
    UserMailer.password_reset(user)
  end

end

http://localhost:3000/rails/mailers/user_mailer/password_reset

# Adding a test of the password reset mailer method
# test/mailers/user_mailer_test.rb # test "password_reset" do
require 'test_helper'

class UserMailerTest < ActionMailer::TestCase
  test "account_activation" do
    user = users(:michael) 
    user.activation_token = User.new_token 
    mail = UserMailer.account_activation(user) 
    assert_equal "Account activation", mail.subject 
    assert_equal [user.email], mail.to 
    assert_equal ["noreply@example.com"], mail.from 
    assert_match user.name, mail.body.encoded 
    assert_match user.activation_token, mail.body.encoded 
    assert_match CGI::escape(user.email), mail.body.encoded
  end

  test "password_reset" do 
    user = users(:michael) 
    user.reset_token = User.new_token 
    mail = UserMailer.password_reset(user) 
    assert_equal "Password reset", mail.subject 
    assert_equal [user.email], mail.to 
    assert_equal ["noreply@example.com"], mail.from 
    assert_match user.reset_token, mail.body.encoded     
    assert_match CGI::escape(user.email), mail.body.encoded 
  end
end

# Note
$ bin/rake db:migrate RAILS_ENV=test
# GREEN 
$ bundle exec rake test
41 runs, 179 assertions, 0 failures, 0 errors, 0 skips

http://localhost:3000/password_resets/new
example@railstutorial.org
"Email sent with password reset instructions."

# Resetting the password To get links of the form [http://example.com/password_resets/3BdBrXeQZSWqFIDRN8cxHA/edit?email=foo%40bar.com] to work, a form for resetting passwords is needed 
# The task is similar to updating users via the user edit view (# The user edit view # app/views/users/edit.html.erb), but in this case with only password and confirmation fields
# Additional complication, though: it is expected to find the user by email address, which means its value is needed in both the edit and update actions
# The email will automatically be available in the edit action because of its presence in the link above, but after the form is submitted its value will be lost
# The solution is to use a hidden field to place (but not display) the email on the page, and then submit it along with the rest of the form's information
# The form to reset a password
# app/views/password_resets/edit.html.erb
<% provide(:title, 'Reset password') %> 
<h1>Reset password</h1> 

<div class="row"> 
  <div class="col-md-6 col-md-offset-3"> 
    <%= form_for(@user, url: password_reset_path(params[:id])) do |f| %> 
      <%= render 'shared/error_messages' %> 

      <%= hidden_field_tag :email, @user.email %> 

      <%= f.label :password %> 
      <%= f.password_field :password, class: 'form-control' %> 

      <%= f.label :password_confirmation, "Confirmation" %> 
      <%= f.password_field :password_confirmation, class: 'form-control' %> 

      <%= f.submit "Update password", class: "btn btn-primary" %> 
    <% end %> 
  </div> 
</div>
# Note that the form to reset a password uses the form tag helper hidden_field_tag :email, @user.email instead of f.hidden_field :email, @user.email
# Because the reset link puts the email in params[:email], whereas the latter would put it inparams[:user][:email]

# To get the form to render, define an @user variable in the Password Resets controller's edit action
# As with account activation (# An edit action to activate accounts #app/controllers/account_activations_controller.rb), this involves finding the user corresponding to the email address in params[:email]
# Then verify that the user is valid, i.e., that it exists, is activated, and is authenticated according to the reset token from params[:id] (using the generalized authenticated? method defined in (# A generalized authenticated? method # app/models/user.rb))
# Because the existence of a valid @user is needed in both the edit and update actions, put the code to find and validate it in a couple of before filters
# The edit action for password reset
# app/controllers/password_resets_controller.rb 
# before_action :get_user, only: [:edit, :update] # before_action :valid_user, only: [:edit, :update] # def get_user # def valid_user 
class PasswordResetsController < ApplicationController
  before_action :get_user, only: [:edit, :update] 
  before_action :valid_user, only: [:edit, :update]

  def new
  end

  def create 
    @user = User.find_by(email: params[:password_reset][:email].downcase) 
    if @user
      @user.create_reset_digest 
      @user.send_password_reset_email 
      flash[:info] = "Email sent with password reset instructions." 
      redirect_to root_url 
    else 
      flash.now[:danger] = "Email address not found." 
      render 'new' 
    end 
  end

  def edit
  end

  private 
    def get_user
      @user = User.find_by(email: params[:email]) 
    end 

    # Confirms a valid user. 
    def valid_user 
      unless (@user && @user.activated? && @user.authenticated?(:reset, params[:id])) 
        redirect_to root_url 
      end 
    end
end
# With the code as above, the link (to reset password) should render a password reset form

# To define the update action corresponding to the edit action in (# The edit action for password reset #app/controllers/password_resets_controller.rb), consider four cases: an expired password reset, a successful update, a failed update (due to an invalid password), and a failed update (which initially looks "successful") due to a blank password and confirmation. 
# The first case applies to both the edit and update actions, and so logically belongs in a before filter as in the following (# The update action for password reset # app/controllers/password_resets_controller.rb)
# The next two cases correspond to the two branches in the main if statement as in the following (# The update action for password reset # app/controllers/password_resets_controller.rb)
# Because the edit form is modifying an Active Record model object (i.e., a user), the shared partial from 
(# The form to reset a password # app/views/password_resets/edit.html.erb) can be used to render error messages
# The only exception is the case where the password is empty, which is currently allowed by our User model (# Allowing empty passwords on update # app/models/user.rb) and so needs to be caught and handled explicitly, in this case is to add an error directly to the @userobject's error messages:
# The update action for password reset 
# app/controllers/password_resets_controller.rb 
# before_action :check_expiration, only: [:edit, :update] # def update # def user_params # def check_expiration 
class PasswordResetsController < ApplicationController
  before_action :get_user, only: [:edit, :update] 
  before_action :valid_user, only: [:edit, :update]
  before_action :check_expiration, only: [:edit, :update]

  def new
  end

  def create 
    @user = User.find_by(email: params[:password_reset][:email].downcase) 
    if @user
      @user.create_reset_digest 
      @user.send_password_reset_email 
      flash[:info] = "Email sent with password reset instructions." 
      redirect_to root_url 
    else 
      flash.now[:danger] = "Email address not found." 
      render 'new' 
    end 
  end

  def edit
  end

  def update 
    if params[:user][:password].empty? 
      flash.now[:danger] = "Password can't be empty." 
      render 'edit' 
    elsif @user.update_attributes(user_params) 
      log_in @user 
      flash[:success] = "Password has been reset." 
      redirect_to @user 
    else 
      render 'edit' 
    end 
  end

  private 
    def user_params 
      params.require(:user).permit(:password, :password_confirmation) 
    end
    
    # Before filters
    def get_user
      @user = User.find_by(email: params[:email]) 
    end 

    # Confirms a valid user. 
    def valid_user 
      unless (@user && @user.activated? && @user.authenticated?(:reset, params[:id])) 
        redirect_to root_url 
      end 
    end

    # Checks expiration of reset token. 
    def check_expiration 
      if @user.password_reset_expired? 
        flash[:danger] = "Password reset has expired." 
        redirect_to new_password_reset_url 
      end 
    end
end

# Adding password reset methods to the User model
# app/models/user.rb
class User < ActiveRecord::Base
  attr_accessor :remember_token, :activation_token, :reset_token 
  before_save :downcase_email 
  before_create :create_activation_digest
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }, allow_nil: true

  # Returns the hash digest of the given string. 
  def User.digest(string) 
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost 
    BCrypt::Password.create(string, cost: cost) 
  end
  
  # Returns a random token. 
  def User.new_token 
    SecureRandom.urlsafe_base64 
  end

  # Remembers a user in the database for use in persistent sessions. 
  def remember 
    self.remember_token = User.new_token 
    update_attribute(:remember_digest, User.digest(remember_token)) 
  end
  
  # Returns true if the given token matches the digest. 
  def authenticated?(attribute, token) 
    digest = send("#{attribute}_digest") 
    return false if digest.nil? 
    BCrypt::Password.new(digest).is_password?(token) 
  end
  
  # Forgets a user. 
  def forget 
    update_attribute(:remember_digest, nil) 
  end

  # Activates an account. 
  def activate 
    update_attribute(:activated, true) 
    update_attribute(:activated_at, Time.zone.now) 
  end 

  # Sends activation email. 
  def send_activation_email 
    UserMailer.account_activation(self).deliver_now 
  end

  # Sets the password reset attributes. 
  def create_reset_digest 
    self.reset_token = User.new_token 
    update_attribute(:reset_digest, User.digest(reset_token)) 
    update_attribute(:reset_sent_at, Time.zone.now) 
  end 

  # Sends password reset email. 
  def send_password_reset_email 
    UserMailer.password_reset(self).deliver_now 
  end
  
  # Returns true if a password reset has expired. 
  def password_reset_expired? 
    reset_sent_at < 2.hours.ago
  end

  private
    # Converts email to all lower-case. 
    def downcase_email 
      self.email = email.downcase 
    end

    # Creates and assigns the activation token and digest.
    def create_activation_digest 
      self.activation_token = User.new_token 
      self.activation_digest = User.digest(activation_token) 
    end
end

# The application's behavior for invalid email addresses is already working
http://localhost:3000/password_resets/new
unknown@unknown.com
<Submit>
http://localhost:3000/password_resets
"Email address not found."

# Password reset test 
# Integration test covering invalid and valid submission
# Get started by generating a test file for password resets
$ rails generate integration_test password_resets

# An integration test for password resets
# test/integration/password_resets_test.rb
require 'test_helper'

class PasswordResetsTest < ActionDispatch::IntegrationTest
  def setup 
    ActionMailer::Base.deliveries.clear 
    @user = users(:michael) 
  end

  test "password resets" do 
    get new_password_reset_path 
    assert_template 'password_resets/new' 
    # Invalid email 
    post password_resets_path, password_reset: { email: "" } 
    assert_not flash.empty? 
    assert_template 'password_resets/new' 
    # Valid email 
    post password_resets_path, password_reset: { email: @user.email } 
    assert_not_equal @user.reset_digest, @user.reload.reset_digest 
    assert_equal 1, ActionMailer::Base.deliveries.size 
    assert_not flash.empty? 
    assert_redirected_to root_url 
    # Password reset form 
    user = assigns(:user) 
    # Wrong email 
    get edit_password_reset_path(user.reset_token, email: "") 
    assert_redirected_to root_url 
    # Inactive user 
    user.toggle!(:activated) 
    get edit_password_reset_path(user.reset_token, email: user.email) 
    assert_redirected_to root_url 
    user.toggle!(:activated) 
    # Right email, wrong token 
    get edit_password_reset_path('wrong token', email: user.email) 
    assert_redirected_to root_url 
    # Right email, right token 
    get edit_password_reset_path(user.reset_token, email: user.email) 
    assert_template 'password_resets/edit' 
    assert_select "input[name=email][type=hidden][value=?]", user.email 
    # Invalid password & confirmation 
    patch password_reset_path(user.reset_token), email: user.email, user: { password: "foobaz", password_confirmation: "barquux" } 
    assert_select 'div#error_explanation'
    # Empty password 
    patch password_reset_path(user.reset_token), email: user.email, user: { password: "", password_confirmation: "" } 
    assert_not flash.empty? 
    assert_template 'password_resets/edit' 
    # Valid password & confirmation 
    patch password_reset_path(user.reset_token), email: user.email, user: { password: "foobaz", password_confirmation: "foobaz" } 
    assert is_logged_in? 
    assert_not flash.empty? 
    assert_redirected_to user 
  end
end

# GREEN 
$ bundle exec rake test
42 runs, 198 assertions, 0 failures, 0 errors, 0 skips

# db/seeds.rb
User.create!(name: "Example User", email: "example@railstutorial.org", 
	password: "foobar", password_confirmation: "foobar", 
	admin: true, 
	activated: true, activated_at: Time.zone.now) 

User.create!(name: "Ruby Admin", email: "*****@gmail.com", 
	password: "********", password_confirmation: "********", 
	admin: true, 
	activated: true, activated_at: Time.zone.now)

User.create!(name: "Ruby NonAdmin", email: "*#*#*@gmail.com", 
	password: "********", password_confirmation: "********", 
	admin: false, 
	activated: true, activated_at: Time.zone.now)

97.times do |n| 
  name = Faker::Name.name 
  email = "example-#{n+1}@railstutorial.org" 
  password = "password" 
  User.create!(name: name, email: email, 
	password: password, password_confirmation: password,
	activated: true, activated_at: Time.zone.now) 
end

# Stop rails server
$ bundle exec rake db:migrate:reset # Note [$ bin/rake db:reset] # Not needed
$ bundle exec rake db:seed
$ bundle exec rake db:migrate
$ bin/rake db:migrate RAILS_ENV=test
$ bundle exec rake test
42 runs, 198 assertions, 0 failures, 0 errors, 0 skips

# Action Mailer Basics
# http://guides.rubyonrails.org/action_mailer_basics.html
[
# Gmail
Note: As of July 15, 2014, Google increased its security measures [https://support.google.com/accounts/answer/6010255] and now blocks attempts from apps it deems less secure. You can change your gmail settings here [https://www.google.com/settings/security/lesssecureapps] to allow the attempts or use another ESP to send email by replacing 'smtp.gmail.com' above with the address of your provider.

# http://www.google.com/accounts/DisplayUnlockCaptcha
]

# Email (in development) # [#####@gmail.com] # [********]

  # Don't care if the mailer can't send.  
  # config.action_mailer.raise_delivery_errors = false  
  # config.action_mailer.raise_delivery_errors = true  
  # config.action_mailer.delivery_method = :test  
  # host = 'localhost:3000' # Local server  
  # config.action_mailer.default_url_options = { host: host }
  config.action_mailer.raise_delivery_errors = true 
  config.action_mailer.delivery_method = :smtp    
  config.action_mailer.default_url_options = { :host => 'localhost:3000' } 
  config.action_mailer.smtp_settings = { 
    :address => 'smtp.gmail.com', :port => '587', 
    :authentication => :plain, 
    :user_name => '#####', 
    :password => '********', 
    :domain => 'gmail.com', 
    :enable_starttls_auto => true 
  }

# config/environments/development.rb
Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # In the development environment your application's code is reloaded on
  # every request. This slows down response time but is perfect for development
  # since you don't have to restart the web server when you make code changes.
  config.cache_classes = false

  # Do not eager load code on boot.
  config.eager_load = false

  # Show full error reports and disable caching.
  config.consider_all_requests_local       = true
  config.action_controller.perform_caching = false

  # Don't care if the mailer can't send.  
  # config.action_mailer.raise_delivery_errors = false  
  # config.action_mailer.raise_delivery_errors = true  
  # config.action_mailer.delivery_method = :test  
  # host = 'localhost:3000' # Local server  
  # config.action_mailer.default_url_options = { host: host }
  config.action_mailer.raise_delivery_errors = true 
  config.action_mailer.delivery_method = :smtp    
  config.action_mailer.default_url_options = { :host => 'localhost:3000' } 
  config.action_mailer.smtp_settings = { 
    :address => 'smtp.gmail.com', :port => '587', 
    :authentication => :plain, 
    :user_name => '#####', 
    :password => '********', 
    :domain => 'gmail.com', 
    :enable_starttls_auto => true 
  }
  
  # Print deprecation notices to the Rails logger.
  config.active_support.deprecation = :log

  # Raise an error on page load if there are pending migrations.
  config.active_record.migration_error = :page_load

  # Debug mode disables concatenation and preprocessing of assets.
  # This option may cause significant delays in view rendering with a large
  # number of complex assets.
  config.assets.debug = true

  # Asset digests allow you to set far-future HTTP expiration dates on all assets,
  # yet still be able to expire them through the digest params.
  config.assets.digest = true

  # Adds additional error checking when serving assets at runtime.
  # Checks for improperly declared sprockets dependencies.
  # Raises helpful error messages.
  config.assets.raise_runtime_errors = true

  # Raises error for missing translations
  # config.action_view.raise_on_missing_translations = true
end

# config/routes.rb # default_url_options :host => "localhost:3000"
Rails.application.routes.draw do
  root 'static_pages#home'
  
  # get 'static_pages/help'
  get 'help' => 'static_pages#help'

  # get 'static_pages/about'
  get 'about' => 'static_pages#about'
  
  # get 'static_pages/contact'
  get 'contact' => 'static_pages#contact'
  
  # get 'users/new'
  get 'signup' => 'users#new'
  
  get 'login' => 'sessions#new' 
  post 'login' => 'sessions#create' 
  delete 'logout' => 'sessions#destroy'
  
  resources :users  
  resources :account_activations, only: [:edit]
  resources :password_resets, only: [:new, :create, :edit, :update]
  
  default_url_options :host => "localhost:3000"
  
  # The priority is based upon order of creation: first created -> highest priority.
  # See how all your routes lay out with "rake routes".

  # You can have the root of your site routed with "root"
  # root 'welcome#index'

  # Example of regular route:
  #   get 'products/:id' => 'catalog#view'

  # Example of named route that can be invoked with purchase_url(id: product.id)
  #   get 'products/:id/purchase' => 'catalog#purchase', as: :purchase

  # Example resource route (maps HTTP verbs to controller actions automatically):
  #   resources :products

  # Example resource route with options:
  #   resources :products do
  #     member do
  #       get 'short'
  #       post 'toggle'
  #     end
  #
  #     collection do
  #       get 'sold'
  #     end
  #   end

  # Example resource route with sub-resources:
  #   resources :products do
  #     resources :comments, :sales
  #     resource :seller
  #   end

  # Example resource route with more complex sub-resources:
  #   resources :products do
  #     resources :comments
  #     resources :sales do
  #       get 'recent', on: :collection
  #     end
  #   end

  # Example resource route with concerns:
  #   concern :toggleable do
  #     post 'toggle'
  #   end
  #   resources :posts, concerns: :toggleable
  #   resources :photos, concerns: :toggleable

  # Example resource route within a namespace:
  #   namespace :admin do
  #     # Directs /admin/products/* to Admin::ProductsController
  #     # (app/controllers/admin/products_controller.rb)
  #     resources :products
  #   end
end

# GREEN
$ bundle exec rake test
42 runs, 198 assertions, 0 failures, 0 errors, 0 skips

# Password reset when logged in
http://localhost:3000/login
Email 
*****@gmail.com
Password
bazqux
<Log in>

[New Tab page]
http://localhost:3000/password_resets/new
*****@gmail.com
<Submit>
http://localhost:3000/
"Email sent with password reset instructions."

[https://mail.google.com/mail/#inbox/157a51c0eb40521a] # [*****@gmail.com] # [********]
Password reset

To reset your password click the link below:

Reset password
This link will expire in two hours.

If you did not request your password to be reset, please ignore this email and your password will stay as it is.

<Reset password>
[http://localhost:3000/password_resets/E5Ud1QmkKgEcQ93u5eC3YQ/edit?email=*****%40gmail.com]
Password
grault
Confirmation
grault
<Update password>
http://localhost:3000/users/2
Account -> Settings
Name 
Ruby Admin
Email 
*****@gmail.com
Account -> Log out

# Password reset when logged out
http://localhost:3000/login
<(forgot password)>
http://localhost:3000/password_resets/new
*****@gmail.com
<Submit>
http://localhost:3000/
"Email sent with password reset instructions."

[https://mail.google.com/mail/#inbox/157a51c0eb40521a] # [*****@gmail.com] # [********]
Password reset

To reset your password click the link below:

Reset password
This link will expire in two hours.

If you did not request your password to be reset, please ignore this email and your password will stay as it is.

<Reset password>
[http://localhost:3000/password_resets/iE2BqjX7yDucnf5tzmiVmA/edit?email=*****%40gmail.com]
Password
garply
Confirmation
garply
<Update password>
http://localhost:3000/users/2
"Password has been reset."
Account -> Log out

# Sign up and Activate

http://localhost:3000/signup
Name
Ruby Signup
Email
#*#*#@gmail.com
Password
waldofred
Confirmation
waldofred
<Create my account>
http://localhost:3000/
"Please check your email to activate your account."

[https://mail.google.com/mail/u/0/#inbox/157a52ed81b6fed4] # [#*#*#@gmail.com] # [https://djangoproject.com]
Sample App

Hi Ruby Signup,

Welcome to the Sample App! Click on the link below to activate your account:

Activate

<Activate>
http://localhost:3000/users/101
"Account activated!"

Account -> Log out

# GREEN
$ bundle exec rake test
42 runs, 198 assertions, 0 failures, 0 errors, 0 skips


## bundle install # Note # Directory renamed
# Gemfile revert
# source 'https://rubygems.org'


# Code coverage
# https://github.com/colszowka/simplecov

# gem 'simplecov', :require => false, :group => :test

# https://rubygems.org/gems/simplecov/versions/0.12.0

gem 'simplecov', '~> 0.12.0'

# install
$ bundle show # Could not find gem 'simplecov (~> 0.12.0) x86-mingw32' in any of the gem sources listed in your Gemfile or available on this machine.
$ gem list
$ bundle install
$ bundle show
$ gem list

# GREEN
$ bundle exec rake test
42 runs, 198 assertions, 0 failures, 0 errors, 0 skips

# simplecov
# https://github.com/colszowka/simplecov
# SimpleCov built-in configurations (see below for information on profiles) that will get it started with groups for the Controllers, Views, Models and Helpers
# To use it, the first two lines of the test_helper should be like this:
require 'simplecov'
SimpleCov.start 'rails'
# test/test_helper.rb
ENV['RAILS_ENV'] ||= 'test'
require File.expand_path('../../config/environment', __FILE__)
require 'rails/test_help'
require 'simplecov'
SimpleCov.start 'rails'

class ActiveSupport::TestCase
  # Setup all fixtures in test/fixtures/*.yml for all tests in alphabetical order.
  fixtures :all

  # Returns true if a test user is logged in. 
  def is_logged_in? 
    !session[:user_id].nil? 
  end

  # Logs in a test user. 
  def log_in_as(user, options = {}) 
    password = options[:password] || 'password' 
    remember_me = options[:remember_me] || '1' 
    if integration_test?
	  post login_path, session: { email: user.email, password: password, remember_me: remember_me } 
    else 
      session[:user_id] = user.id 
    end 
  end

  private
    # Returns true inside an integration test. 
    def integration_test? 
      defined?(post_via_redirect) 
    end
end

# GREEN
$ bundle exec rake test
42 runs, 198 assertions, 0 failures, 0 errors, 0 skips
Coverage report generated for MiniTest to E:/Working/Ruby/Ruby-on-Rails/Learn-Web-Development-with-Rails/Third-Edition/workspace/sample_app/coverage. 208 / 211 LOC (98.58%) covered
# coverage/index.html

$ bin/rails server
http://localhost:3000
http://localhost:3000/login
*****@gmail.com
garply